{
    "docs": [
        {
            "location": "/", 
            "text": "REMnux Documentation\n\n\nThis site provides  documentation for \nREMnux\n,\n a free Linux toolkit for reverse-engineering and analyzing malware. REMnux strives to make it easier for forensic investigators and incident responders to start using the variety of freely-available tools that can examine malware, yet might be difficult to find or set up.\n\n\nThe heart of the project is the \nREMnux Linux distribution\n based on Ubuntu This lightweight distro incorporates many tools for analyzing Windows and Linux malware, examining browser-based threats such as obfuscated JavaScript, exploring suspicious document files and taking apart other malicious artifacts. Investigators can also use the distro to intercept suspicious network traffic in an isolated lab when performing behavioral malware analysis.\n\n\nAnother REMnux initiative involves building Docker \nimages of popular malware analysis tools\n. The goals of this effort is to allow investigators to conveniently utilize difficult-to-setup applications without having to install the REMnux distro. You can run Dockerized application containers as part of your existing environment.\n\n\nREMnux is maintained by \nLenny Zeltser\n with extensive help from \nDavid Westcott\n. You can learn the malware analysis techniques that make use of the tools installed and pre-configured on the REMnux distro by taking \nReverse-Engineering Malware training\n at SANS Institute.", 
            "title": "Docs Home"
        }, 
        {
            "location": "/#remnux-documentation", 
            "text": "This site provides  documentation for  REMnux ,  a free Linux toolkit for reverse-engineering and analyzing malware. REMnux strives to make it easier for forensic investigators and incident responders to start using the variety of freely-available tools that can examine malware, yet might be difficult to find or set up.  The heart of the project is the  REMnux Linux distribution  based on Ubuntu This lightweight distro incorporates many tools for analyzing Windows and Linux malware, examining browser-based threats such as obfuscated JavaScript, exploring suspicious document files and taking apart other malicious artifacts. Investigators can also use the distro to intercept suspicious network traffic in an isolated lab when performing behavioral malware analysis.  Another REMnux initiative involves building Docker  images of popular malware analysis tools . The goals of this effort is to allow investigators to conveniently utilize difficult-to-setup applications without having to install the REMnux distro. You can run Dockerized application containers as part of your existing environment.  REMnux is maintained by  Lenny Zeltser  with extensive help from  David Westcott . You can learn the malware analysis techniques that make use of the tools installed and pre-configured on the REMnux distro by taking  Reverse-Engineering Malware training  at SANS Institute.", 
            "title": "REMnux Documentation"
        }, 
        {
            "location": "/distro/get/", 
            "text": "The heart of the \nREMnux\n project is the REMnux Linux distribution based on \nUbuntu\n. This lightweight distro incorporates many tools for analyzing Windows and Linux malware, examining browser-based threats such as obfuscated JavaScript, exploring suspicious document files and taking apart other malicious artifacts. Investigators can also use the distro to intercept suspicious network traffic in an isolated lab when performing behavioral malware analysis.\n\n\nDownload the REMnux Virtual Appliance\n\n\nThe simplest way to get the distro is to \ndownload the REMnux virtual appliance file\n in the OVA format. \n\n\nThe file is around 2GB in size; its SHA-256 hash is C26BE9831CA414F5A4D908D793E0B8934470B3887C48CFE82F86943236968AE6. You\nll need to install virtualization software such as \nVMware Player\n, \nVMware Workstation\n, \nVMware Fusion\n and \nVirtualBox\n prior to using the REMnux virtual appliance.\n\n\nImport the REMnux Virtual Appliance\n\n\nOnce you\nve downloaded the REMnux OVA file, import it into your virtualization software, then start the virtual machine. For step-by-step instructions for importing the virtual appliance, take a look at the \nVirtualBox screenshot\n and \nVMware Workstation screenshot\n slideshows.\n\n\nThere is no need to extract contents of the OVA file manually before importing it. Simply load the OVA file into your virtualization software to begin the import. If you attempt to extract OVA file\ns contents and try importing the embedded OVF file in VirtualBox, you will likely encounter an error, such as \ncould not verify the content of REMnux.mf against the available files, unsupported digest type.\n\n\nIf importing into \nQEMU\n, extract contents of the OVA file and run the qemu-img command like this:\n\n\ntar xvf remnux-6.0-ova-public.ova\nqemu-img convert -O qcow2 REMnuxV6-disk1.vmdk remnux.qcow2\n\n\n\nIn all cases, once you boot up the imported virtual machine, it will automatically log you into the system using the user named \nremnux\n. The user\ns password is \nmalware\n; you might need to specify it when performing privileged operations.\n\n\nAfter booting into the virtual appliance, run the \nupdate-remnux full\n command on REMnux to update its software. This will allow you to benefit from any enhancements introduced after the virtual appliance has been packaged. Your system needs to have Internet access for this to work.\n\n\nInstall REMnux on an Existing System\n\n\nAs an alternative to downloading the virtual appliance, you can run the REMnux installation script on an existing Ubuntu 14.04 64-bit system. This allows you to install REMnux on a physical host or a virtual machine. You can use this method to add REMnux software and settings to a brand new system or to the host you\nve been using for a while. \nSIFT Workstation \n users can utilize this approach to \ncombine SIFT and REMnux into a single system\n.\n\n\nIf you\nd like to build a REMnux system from scratch, use the \nUbuntu 14.04 64-bit minimal ISO\n as the starting point. If building a virtual machine, allocate at least 1GB of RAM and 25GB disk (more recommended). When going through the Ubuntu installer, consider creating the user named \nremnux\n with the password \nmalware\n, though any credentials will work. For step-by-step instructions, see the \nscreenshots of the Ubuntu installation steps\n.\n\n\nOnce you\nve logged into the newly-built or existing system compatible with REMnux, run the following command to install the REMnux distro:\n\n\nwget --quiet -O - https://remnux.org/get-remnux.sh | sudo bash\n\n\n\nThis installation script will configure your system and download and install the necessary software without asking you any questions. It requires Internet access to accomplish this. The installer will run for approximately 45 minutes, depending on the strength of your system and the speed of your Internet connection.\n\n\nA handful of people running the installation script within virtual machines noticed that the antivirus tool installed on their underlying host flagged some REMnux packages as malicious and blocked their download. This is a false alarm. However, if you encounter this, you might need to disable the host\ns anivirus tool while running the script or whitelist the offending files or URLs to avoid getting them blocked.\n\n\nConnecting the REMnux Virtual Appliance to the Internet\n\n\nThe REMnux virtual appliance is initially configured to use the \nNAT\n mode, so it can connect to the Internet through the host on which it is running. This way, if your underlying host has Internet connectivity, REMnux should be able to access the Internet as well. You can isolate REMnux within your lab by configuring the virtual appliance to use a \nhost only\n network. After switching networks, run the \nrenew-dhcp\n command in REMnux to refresh its network settings.\n\n\nSome of the REMnux tools are designed to run in an \nisolated laboratory environment\n, so you can perform behavioral analysis of malicious software running in the lab. In this case, configure REMnux use a virtual network without Internet connectivity. Other tools are designed to allow you to explore suspicious websites and interact with online resources; REMnux will need to be connected to an Internet-accessible network when performing these tasks.\n\n\nInstalling Virtualization Tools on REMnux\n\n\nWhen running REMnux on a VMware platform, it\ns usually a good idea to install VMware Tools within the virtual machine. This will allow the REMnux screen resolution to automatically adust to match your monitor\ns geometry. It will also provide some additional enhancements, such as the opportunity to share clipboard contents across your underlying host and the virtual machine.\n\n\nWhen running REMnux on VMware Workstation, Player or ESX, the simplest way to install VMware Tools using the open VM tools package by running the following command on REMnux, assuming it\ns connected to the Internet:\n\n\nsudo apt-get install open-vm-tools-desktop\n\n\n\nOn VMware Fusion, the best approach is to install proprietary VMware Tools. To do this, activate the VMware Tools installation via Virtual Machine \n Install VMware Tools, then run the command \nsudo install-vmware-tools\n on REMnux. You can install VMware Tools this way on VMware Workstation and Player as well. For additional details, see the \nVMware article on this topic\n.\n\n\nPlease note that if you wish to use the shared folders feature of VMware, you will need to install proprietary VMware Tools with several adjustments to compensate for a compatibility issue between VMware Tools and the Ubuntu-supplied Linux kernel. These steps are described in an \narticle devoted to this topic\n. A more practical option for transferring files in and out of REMnux might be to use SFTP through the installed SSH server (\nsshd start\n) instead of using shared folders.\n\n\nIf using VirtualBox, consider installing Guest Additions software. To accomplish this, first shut down the REMnux virtual machine, then use the VirtalBox menu Devices \n Insert guest additions CD image, then start up the VM. Mount the virtual CD containing Guest Additions software like this and reboot:\n\n\nsudo mount /dev/sr0 /mnt/cdrom\nsudo /mnt/cdrom/VBoxLinuxAdditions.*\n\n\n\nUpdating Your REMnux System\n\n\nTo update REMnux after connecting your system to the Internet, simply run the \nupdate-remnux\n command. This tool will update the software that comprises the REMnux distribution, which includes the applications installed from standard Ubuntu and the REMnux-specific repository. The updater will also installed any tools added to the distro after your last update.", 
            "title": "Get the REMnux Distro"
        }, 
        {
            "location": "/distro/get/#download-the-remnux-virtual-appliance", 
            "text": "The simplest way to get the distro is to  download the REMnux virtual appliance file  in the OVA format.   The file is around 2GB in size; its SHA-256 hash is C26BE9831CA414F5A4D908D793E0B8934470B3887C48CFE82F86943236968AE6. You ll need to install virtualization software such as  VMware Player ,  VMware Workstation ,  VMware Fusion  and  VirtualBox  prior to using the REMnux virtual appliance.", 
            "title": "Download the REMnux Virtual Appliance"
        }, 
        {
            "location": "/distro/get/#import-the-remnux-virtual-appliance", 
            "text": "Once you ve downloaded the REMnux OVA file, import it into your virtualization software, then start the virtual machine. For step-by-step instructions for importing the virtual appliance, take a look at the  VirtualBox screenshot  and  VMware Workstation screenshot  slideshows.  There is no need to extract contents of the OVA file manually before importing it. Simply load the OVA file into your virtualization software to begin the import. If you attempt to extract OVA file s contents and try importing the embedded OVF file in VirtualBox, you will likely encounter an error, such as  could not verify the content of REMnux.mf against the available files, unsupported digest type.  If importing into  QEMU , extract contents of the OVA file and run the qemu-img command like this:  tar xvf remnux-6.0-ova-public.ova\nqemu-img convert -O qcow2 REMnuxV6-disk1.vmdk remnux.qcow2  In all cases, once you boot up the imported virtual machine, it will automatically log you into the system using the user named  remnux . The user s password is  malware ; you might need to specify it when performing privileged operations.  After booting into the virtual appliance, run the  update-remnux full  command on REMnux to update its software. This will allow you to benefit from any enhancements introduced after the virtual appliance has been packaged. Your system needs to have Internet access for this to work.", 
            "title": "Import the REMnux Virtual Appliance"
        }, 
        {
            "location": "/distro/get/#install-remnux-on-an-existing-system", 
            "text": "As an alternative to downloading the virtual appliance, you can run the REMnux installation script on an existing Ubuntu 14.04 64-bit system. This allows you to install REMnux on a physical host or a virtual machine. You can use this method to add REMnux software and settings to a brand new system or to the host you ve been using for a while.  SIFT Workstation   users can utilize this approach to  combine SIFT and REMnux into a single system .  If you d like to build a REMnux system from scratch, use the  Ubuntu 14.04 64-bit minimal ISO  as the starting point. If building a virtual machine, allocate at least 1GB of RAM and 25GB disk (more recommended). When going through the Ubuntu installer, consider creating the user named  remnux  with the password  malware , though any credentials will work. For step-by-step instructions, see the  screenshots of the Ubuntu installation steps .  Once you ve logged into the newly-built or existing system compatible with REMnux, run the following command to install the REMnux distro:  wget --quiet -O - https://remnux.org/get-remnux.sh | sudo bash  This installation script will configure your system and download and install the necessary software without asking you any questions. It requires Internet access to accomplish this. The installer will run for approximately 45 minutes, depending on the strength of your system and the speed of your Internet connection.  A handful of people running the installation script within virtual machines noticed that the antivirus tool installed on their underlying host flagged some REMnux packages as malicious and blocked their download. This is a false alarm. However, if you encounter this, you might need to disable the host s anivirus tool while running the script or whitelist the offending files or URLs to avoid getting them blocked.", 
            "title": "Install REMnux on an Existing System"
        }, 
        {
            "location": "/distro/get/#connecting-the-remnux-virtual-appliance-to-the-internet", 
            "text": "The REMnux virtual appliance is initially configured to use the  NAT  mode, so it can connect to the Internet through the host on which it is running. This way, if your underlying host has Internet connectivity, REMnux should be able to access the Internet as well. You can isolate REMnux within your lab by configuring the virtual appliance to use a  host only  network. After switching networks, run the  renew-dhcp  command in REMnux to refresh its network settings.  Some of the REMnux tools are designed to run in an  isolated laboratory environment , so you can perform behavioral analysis of malicious software running in the lab. In this case, configure REMnux use a virtual network without Internet connectivity. Other tools are designed to allow you to explore suspicious websites and interact with online resources; REMnux will need to be connected to an Internet-accessible network when performing these tasks.", 
            "title": "Connecting the REMnux Virtual Appliance to the Internet"
        }, 
        {
            "location": "/distro/get/#installing-virtualization-tools-on-remnux", 
            "text": "When running REMnux on a VMware platform, it s usually a good idea to install VMware Tools within the virtual machine. This will allow the REMnux screen resolution to automatically adust to match your monitor s geometry. It will also provide some additional enhancements, such as the opportunity to share clipboard contents across your underlying host and the virtual machine.  When running REMnux on VMware Workstation, Player or ESX, the simplest way to install VMware Tools using the open VM tools package by running the following command on REMnux, assuming it s connected to the Internet:  sudo apt-get install open-vm-tools-desktop  On VMware Fusion, the best approach is to install proprietary VMware Tools. To do this, activate the VMware Tools installation via Virtual Machine   Install VMware Tools, then run the command  sudo install-vmware-tools  on REMnux. You can install VMware Tools this way on VMware Workstation and Player as well. For additional details, see the  VMware article on this topic .  Please note that if you wish to use the shared folders feature of VMware, you will need to install proprietary VMware Tools with several adjustments to compensate for a compatibility issue between VMware Tools and the Ubuntu-supplied Linux kernel. These steps are described in an  article devoted to this topic . A more practical option for transferring files in and out of REMnux might be to use SFTP through the installed SSH server ( sshd start ) instead of using shared folders.  If using VirtualBox, consider installing Guest Additions software. To accomplish this, first shut down the REMnux virtual machine, then use the VirtalBox menu Devices   Insert guest additions CD image, then start up the VM. Mount the virtual CD containing Guest Additions software like this and reboot:  sudo mount /dev/sr0 /mnt/cdrom\nsudo /mnt/cdrom/VBoxLinuxAdditions.*", 
            "title": "Installing Virtualization Tools on REMnux"
        }, 
        {
            "location": "/distro/get/#updating-your-remnux-system", 
            "text": "To update REMnux after connecting your system to the Internet, simply run the  update-remnux  command. This tool will update the software that comprises the REMnux distribution, which includes the applications installed from standard Ubuntu and the REMnux-specific repository. The updater will also installed any tools added to the distro after your last update.", 
            "title": "Updating Your REMnux System"
        }, 
        {
            "location": "/distro/tools/", 
            "text": "The REMnux\n distribution includes many free tools useful for examining malicious software. These utilities are set up and tested to make it easier for you to perform malware analysis tasks without needing to figure out how to install them. The majority of these tools are listed below.\n\n\nFor more details, including each tool\ns description and source, see the XLSX \nspreadsheet\n or the XMind-formatted \nmind map\n. You can also get an overview of the key tools and commands on the \nREMnux cheat sheet\n.\n\n\nExamine Browser Malware\n\n\n\n\nWebsite analysis: \nThug\n, \nmitmproxy\n, \nNetwork Miner Free Edition\n, \ncurl\n, \nWget\n, \nBurp Proxy Free Edition\n, \nAutomater\n, \npdnstool\n,  \nTor\n, \ntcpextract\n, \ntcpflow\n, \npassive.py\n, \nCapTipper\n, \nyaraPcap.py\n\n\nFlash: \nxxxswf\n, \nSWF Tools\n, \nRABCDAsm\n, \nextract_swf\n, \nFlare\n\n\nJava: \nJava Cache IDX Parser\n, \nJD-GUI Java Decompiler\n, \nJAD Java Decompiler\n, \nJavassist\n, \nCFR\n\n\nJavaScript: \nRhino Debugger\n, \nExtractScripts\n, \nFirebug\n,  \nSpiderMonkey\n, \nV8\n, \nJS Beautifier\n\n\n\n\nExamine Document Files\n\n\n\n\nPDF: \nAnalyzePDF\n, \nPdfobjflow\n, \npdfid\n, \npdf-parser\n, \npeepdf\n, \nOrigami\n, \nPDF X-RAY Lite\n, \nPDFtk\n, \nswf_mastah\n\n\nMicrosoft Office: \nofficeparser\n, \npyOLEScanner.py\n, \noletools\n, \nlibolecf\n, \noledump\n, \nemldump\n, \nMSGConvert\n, \nbase64dump.py\n\n\nShellcode: \nsctest\n, unicode2hex-escaped, unicode2raw, \ndism-this\n, \nshellcode2exe\n\n\n\n\nExtract and Decode Artifacts\n\n\n\n\nDeobfuscate: \nunXOR\n, \nXORStrings\n, \nex_pe_xor\n, \nXORSearch\n, \nbrxor.py\n, \nxortool\n, \nNoMoreXOR\n, \nXORBruteForcer\n, \nBalbuzard\n\n\nExtract strings: \nstrdeobj\n, \npestr\n, \nstrings\n\n\nCarving: \nForemost\n, \nScalpel\n, \nbulk_extractor\n, \nHachoir\n\n\n\n\nHandle Network Interactions\n\n\n\n\nSniffing: \nWireshark\n, \nngrep\n, \nTCPDump\n, \ntcpick\n\n\nServices: \nFakeDNS\n, \nNginx\n, \nfakeMail\n, \nHoneyd\n, \nINetSim\n, \nInspire IRCd\n, \nOpenSSH\n, accept-all-ips\n\n\nMiscellaneous network: \nprettyping.sh\n, set-static-ip, renew-dhcp, \nNetcat\n, \nEPIC IRC Client\n, \nstunnel\n\n\n\n\nProcess Multiple Samples\n\n\n\n\nMaltrieve\n, \nRagpicker\n, \nViper\n, \nMASTIFF\n, \nDensity Scout\n\n\n\n\nExamine File Properties and Contents\n\n\n\n\nDefine signatures: \nYaraGenerator\n, \nIOCextractor\n, \nAutorule\n, \nRule Editor\n\n\nScan: \nYara\n, \nClamAV\n, \nTrID\n, \nExifTool\n, \nvirustotal-submit\n, \nDisitool\n\n\nHashes: \nnsrllookup\n, \nAutomater\n, \nHash Identifier\n, \ntotalhash\n, \nssdeep\n, \nvirustotal-search\n, \nVirusTotalApi\n\n\n\n\nInvestigate Linux Malware\n\n\n\n\nSystem: \nSysdig\n, \nUnhide\n\n\nDisassemble: \nVivisect\n, \nUdis86\n, \nobjdump\n\n\nDebug: \nEvan\ns Debugger (EDB)\n, \nGNU Project Debugger (GDB)\n\n\nTrace: \nstrace\n, \nltrace\n\n\nInvestigate: \nRadare 2\n, \nPyew\n, \nBokken\n, \nm2elf\n\n\n\n\nEdit and View Files\n\n\n\n\nText: \nSciTE\n, \nGeany\n, \nVim\n\n\nImages: \nfeh\n, \nImageMagick\n\n\nBinary: \nwxHexEditor\n, \nVBinDiff\n\n\nDocuments: \nXpdf\n\n\n\n\nExamine Memory Snapshots\n\n\n\n\nVolatility Framework\n, \nfindaes\n, AESKeyFinder, RSAKeyFinder, \nVolDiff\n, \nRekall\n\n\n\n\nStatically Examine PE Files\n\n\n\n\nUnpacking: \nUPX\n, \nBytehist\n, \nDensity Scout\n, \nPackerID\n\n\nDisassemble: \nobjdump\n, \nUdis86\n, \nVivisect\n\n\nFind anomalies: \nSignsrch\n, \npescanner\n, \nExeScan\n, \npev\n, \nPeframe\n, \npedump\n\n\nInvestigate: \nBokken\n, \nRATDecoders\n, \nPyew\n, \nreadpe.py\n, \nPyInstaller Extractor\n, \nDC3-MWCP\n\n\n\n\nInvestigate Mobile Malware\n\n\n\n\nAndrowarn\n, \nAndroGuard\n\n\n\n\nPerform Other Tasks\n\n\n\n\nProcDOT\n, \nbashhacks\n, \nDocker\n, \nvtTool\n, REMnux Updater, \nDecompyle++\n\n\n\n\nInstall Additional Tools\n\n\n\n\n\n\nMetasploit\n is not installed on REMnux; however, \nyou can install it yourself\n if the need arises.\n\n\n\n\n\n\nWIPSTER\n offers a web-based interface to several REMnux tools. You can easily install WIPSTER on REMnux by running the command \ninstall-wipster\n.", 
            "title": "Tools Installed on REMnux"
        }, 
        {
            "location": "/distro/tools/#examine-browser-malware", 
            "text": "Website analysis:  Thug ,  mitmproxy ,  Network Miner Free Edition ,  curl ,  Wget ,  Burp Proxy Free Edition ,  Automater ,  pdnstool ,   Tor ,  tcpextract ,  tcpflow ,  passive.py ,  CapTipper ,  yaraPcap.py  Flash:  xxxswf ,  SWF Tools ,  RABCDAsm ,  extract_swf ,  Flare  Java:  Java Cache IDX Parser ,  JD-GUI Java Decompiler ,  JAD Java Decompiler ,  Javassist ,  CFR  JavaScript:  Rhino Debugger ,  ExtractScripts ,  Firebug ,   SpiderMonkey ,  V8 ,  JS Beautifier", 
            "title": "Examine Browser Malware"
        }, 
        {
            "location": "/distro/tools/#examine-document-files", 
            "text": "PDF:  AnalyzePDF ,  Pdfobjflow ,  pdfid ,  pdf-parser ,  peepdf ,  Origami ,  PDF X-RAY Lite ,  PDFtk ,  swf_mastah  Microsoft Office:  officeparser ,  pyOLEScanner.py ,  oletools ,  libolecf ,  oledump ,  emldump ,  MSGConvert ,  base64dump.py  Shellcode:  sctest , unicode2hex-escaped, unicode2raw,  dism-this ,  shellcode2exe", 
            "title": "Examine Document Files"
        }, 
        {
            "location": "/distro/tools/#extract-and-decode-artifacts", 
            "text": "Deobfuscate:  unXOR ,  XORStrings ,  ex_pe_xor ,  XORSearch ,  brxor.py ,  xortool ,  NoMoreXOR ,  XORBruteForcer ,  Balbuzard  Extract strings:  strdeobj ,  pestr ,  strings  Carving:  Foremost ,  Scalpel ,  bulk_extractor ,  Hachoir", 
            "title": "Extract and Decode Artifacts"
        }, 
        {
            "location": "/distro/tools/#handle-network-interactions", 
            "text": "Sniffing:  Wireshark ,  ngrep ,  TCPDump ,  tcpick  Services:  FakeDNS ,  Nginx ,  fakeMail ,  Honeyd ,  INetSim ,  Inspire IRCd ,  OpenSSH , accept-all-ips  Miscellaneous network:  prettyping.sh , set-static-ip, renew-dhcp,  Netcat ,  EPIC IRC Client ,  stunnel", 
            "title": "Handle Network Interactions"
        }, 
        {
            "location": "/distro/tools/#process-multiple-samples", 
            "text": "Maltrieve ,  Ragpicker ,  Viper ,  MASTIFF ,  Density Scout", 
            "title": "Process Multiple Samples"
        }, 
        {
            "location": "/distro/tools/#examine-file-properties-and-contents", 
            "text": "Define signatures:  YaraGenerator ,  IOCextractor ,  Autorule ,  Rule Editor  Scan:  Yara ,  ClamAV ,  TrID ,  ExifTool ,  virustotal-submit ,  Disitool  Hashes:  nsrllookup ,  Automater ,  Hash Identifier ,  totalhash ,  ssdeep ,  virustotal-search ,  VirusTotalApi", 
            "title": "Examine File Properties and Contents"
        }, 
        {
            "location": "/distro/tools/#investigate-linux-malware", 
            "text": "System:  Sysdig ,  Unhide  Disassemble:  Vivisect ,  Udis86 ,  objdump  Debug:  Evan s Debugger (EDB) ,  GNU Project Debugger (GDB)  Trace:  strace ,  ltrace  Investigate:  Radare 2 ,  Pyew ,  Bokken ,  m2elf", 
            "title": "Investigate Linux Malware"
        }, 
        {
            "location": "/distro/tools/#edit-and-view-files", 
            "text": "Text:  SciTE ,  Geany ,  Vim  Images:  feh ,  ImageMagick  Binary:  wxHexEditor ,  VBinDiff  Documents:  Xpdf", 
            "title": "Edit and View Files"
        }, 
        {
            "location": "/distro/tools/#examine-memory-snapshots", 
            "text": "Volatility Framework ,  findaes , AESKeyFinder, RSAKeyFinder,  VolDiff ,  Rekall", 
            "title": "Examine Memory Snapshots"
        }, 
        {
            "location": "/distro/tools/#statically-examine-pe-files", 
            "text": "Unpacking:  UPX ,  Bytehist ,  Density Scout ,  PackerID  Disassemble:  objdump ,  Udis86 ,  Vivisect  Find anomalies:  Signsrch ,  pescanner ,  ExeScan ,  pev ,  Peframe ,  pedump  Investigate:  Bokken ,  RATDecoders ,  Pyew ,  readpe.py ,  PyInstaller Extractor ,  DC3-MWCP", 
            "title": "Statically Examine PE Files"
        }, 
        {
            "location": "/distro/tools/#investigate-mobile-malware", 
            "text": "Androwarn ,  AndroGuard", 
            "title": "Investigate Mobile Malware"
        }, 
        {
            "location": "/distro/tools/#perform-other-tasks", 
            "text": "ProcDOT ,  bashhacks ,  Docker ,  vtTool , REMnux Updater,  Decompyle++", 
            "title": "Perform Other Tasks"
        }, 
        {
            "location": "/distro/tools/#install-additional-tools", 
            "text": "Metasploit  is not installed on REMnux; however,  you can install it yourself  if the need arises.    WIPSTER  offers a web-based interface to several REMnux tools. You can easily install WIPSTER on REMnux by running the command  install-wipster .", 
            "title": "Install Additional Tools"
        }, 
        {
            "location": "/distro/use/", 
            "text": "This section will contain documentation about the tools installed on the REMnux\n distro. Would you like to \ncontribute your insights on REMnux and its tools\n to expand this document set?\n\n\nTools Installed on REMnux\n\n\nThe \nlisting of tools installed on REMnux\n outlines and categorizes the utilities you can use for analyzing malicious software on REMnux. For additional details, take a look at the XLSX \nspreadsheet\n or the XMind-formatted \nmind map\n, which outline these tools.\n\n\nREMnux Cheat Sheet\n\n\nThe one-page \nREMnux cheat sheet\n highlights some of the most useful tools and commands available on REMnux. It\ns an especially nice starting point for people who are new to the distro.\n\n\nRecorded REMnux Webcasts\n\n\nTo get started with the REMnux distro and become familiar with some of its capabilities, tune into the following recorded webcasts:\n\n\n\n\nMalware Analysis Essentials Using REMnux\n by Lenny Zeltser\n\n\nWhat\ns New in REMnux v4\n by Lenny Zeltser\n\n\nHow to analyze malware with REMnux\ns reverse-engineering malware tools\n by Keith Barker\n\n\n\n\nArticles on Using REMnux\n\n\nHere are some of the blog posts and articles written about using REMnux for malware analysis:\n\n\n\n\nDynamic Malware Analysis With REMnux\n by Luis Rocha, continued in \npart 2\n\n\nMemory Forensics With Volatility on REMnux\n by Luis Rocha, continued in \npart 2\n\n\nGetting What You Want Out of a PDF with REMnux\n by Glenn Edwards\n\n\nREMnux: Reverse-Engineering Malware\n by Michael Kassner\n\n\nMalware Analysis Lab - A Fast and Cost Effective \nHowTo\n by ThreatConnect\n\n\nREMnux Tutorial: Statically Analyse Portable Executablei (PE) Files\n by Rhydham Joshi, continued in \nPart 2: Extraction and Decoding of Artifacts\n\n\nAnalyzing Office Weaponized Documents\n by dfir it!\n\n\nMalicious Documents - PDF Analysis in 5 Steps\n by Luis Rocha\n\n\nREMnux v6 for Malware Analysis: VolDiff\n by Anuj Soni\n\n\nHow to Use Thug Honeyclient to Investigate a Malicious Website\n by John Hubbard\n\n\n\n\nIf you write or locate other tutorials or articles that demonstrate the use of REMnux, please \nlet Lenny Zeltser know\n.\n\n\nKnown Issues\n\n\nWhen importing the REMnux virtual appliance into an old version of VMware Workstation, Fusion or Player, you may get the error message that states, \nFailed to open virtual machine: Failed to query source for information.\n In this case, you should upgrade to a later version of VMware software. If upgrading is not feasible, you may be able to use the \nVMware OVF Tool\n to convert the REMnux OVA file to the VMX format.\n\n\nWhen using VMware Fusion to run the REMnux virtual machine, the VM might stop recognizing the mouse clicks. \nAccording to VMware\n, this occurs when the \nvirtual machine detects the connected mouse as a USB device and not as a HID device. While the mouse pointer may still move within the virtual machine, mouse clicks do not register.\n To address the problem, edit the .VMX file of your REMnux virutal machine to include the following line:\n\n\nmouse.vusb.startConnected = \"FALSE\"\n\n\n\nA handful of people running REMnux installation or update scripts within virtual machines noticed that the antivirus tool installed on their underlying host flagged some REMnux packages as malicious and blocked their download. This is a false alarm. However, if you encounter this, you might need to disable the host\ns anivirus tool while running the script or whitelist the offending files or URLs to avoid getting them blocked.", 
            "title": "Using REMnux and Its Tools"
        }, 
        {
            "location": "/distro/use/#tools-installed-on-remnux", 
            "text": "The  listing of tools installed on REMnux  outlines and categorizes the utilities you can use for analyzing malicious software on REMnux. For additional details, take a look at the XLSX  spreadsheet  or the XMind-formatted  mind map , which outline these tools.", 
            "title": "Tools Installed on REMnux"
        }, 
        {
            "location": "/distro/use/#remnux-cheat-sheet", 
            "text": "The one-page  REMnux cheat sheet  highlights some of the most useful tools and commands available on REMnux. It s an especially nice starting point for people who are new to the distro.", 
            "title": "REMnux Cheat Sheet"
        }, 
        {
            "location": "/distro/use/#recorded-remnux-webcasts", 
            "text": "To get started with the REMnux distro and become familiar with some of its capabilities, tune into the following recorded webcasts:   Malware Analysis Essentials Using REMnux  by Lenny Zeltser  What s New in REMnux v4  by Lenny Zeltser  How to analyze malware with REMnux s reverse-engineering malware tools  by Keith Barker", 
            "title": "Recorded REMnux Webcasts"
        }, 
        {
            "location": "/distro/use/#articles-on-using-remnux", 
            "text": "Here are some of the blog posts and articles written about using REMnux for malware analysis:   Dynamic Malware Analysis With REMnux  by Luis Rocha, continued in  part 2  Memory Forensics With Volatility on REMnux  by Luis Rocha, continued in  part 2  Getting What You Want Out of a PDF with REMnux  by Glenn Edwards  REMnux: Reverse-Engineering Malware  by Michael Kassner  Malware Analysis Lab - A Fast and Cost Effective  HowTo  by ThreatConnect  REMnux Tutorial: Statically Analyse Portable Executablei (PE) Files  by Rhydham Joshi, continued in  Part 2: Extraction and Decoding of Artifacts  Analyzing Office Weaponized Documents  by dfir it!  Malicious Documents - PDF Analysis in 5 Steps  by Luis Rocha  REMnux v6 for Malware Analysis: VolDiff  by Anuj Soni  How to Use Thug Honeyclient to Investigate a Malicious Website  by John Hubbard   If you write or locate other tutorials or articles that demonstrate the use of REMnux, please  let Lenny Zeltser know .", 
            "title": "Articles on Using REMnux"
        }, 
        {
            "location": "/distro/use/#known-issues", 
            "text": "When importing the REMnux virtual appliance into an old version of VMware Workstation, Fusion or Player, you may get the error message that states,  Failed to open virtual machine: Failed to query source for information.  In this case, you should upgrade to a later version of VMware software. If upgrading is not feasible, you may be able to use the  VMware OVF Tool  to convert the REMnux OVA file to the VMX format.  When using VMware Fusion to run the REMnux virtual machine, the VM might stop recognizing the mouse clicks.  According to VMware , this occurs when the  virtual machine detects the connected mouse as a USB device and not as a HID device. While the mouse pointer may still move within the virtual machine, mouse clicks do not register.  To address the problem, edit the .VMX file of your REMnux virutal machine to include the following line:  mouse.vusb.startConnected = \"FALSE\"  A handful of people running REMnux installation or update scripts within virtual machines noticed that the antivirus tool installed on their underlying host flagged some REMnux packages as malicious and blocked their download. This is a false alarm. However, if you encounter this, you might need to disable the host s anivirus tool while running the script or whitelist the offending files or URLs to avoid getting them blocked.", 
            "title": "Known Issues"
        }, 
        {
            "location": "/distro/update/", 
            "text": "Starting with the \nv6 release\n, the REMnux distro allows its users to conveniently update REMnux software without having to install the updated REMnux system from scratch. To do this, first connect your REMnux system to the Internet. Then run the following command:\n\n\nupdate-remnux\n\n\n\nThe script takes 5-10 minutes to run, depending on the speed of your Internet connection and the power of your host. It will update the packages intalled as part of the REMnux environment and add any tools incorporated into the distro since your previous update.\n\n\nIf you\nve added any tools to your environment using \napt-get\n beyond those that came with REMnux, you can run the following commands after \nupdate-remnux\n:\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\nConsider following REMnux accounts on \nTwitter\n, \nFacebook\n and \nGoogle Plus\n to receive notifications when its malware analysis packages are updated or when new ones are added to the toolkit.", 
            "title": "Keeping REMnux Up-To-Date"
        }, 
        {
            "location": "/containers/malware-analysis/", 
            "text": "One aspect of the REMnux\n project involves providing \nDocker\n images of popular malware analysis tools, with the goal of allowing investigators to conveniently utilize difficult-to-install applications without having to install the REMnux distro. Such images could be compared to lightweight virtual machines; though they don\nt offer the same level of isolation as real VMs, they provide a container within which the application can be encapsulated along with its dependencies.\n\n\nSee documentation below for more information and tune into the recorded webcast \nHow to Run Linux Malware Analysis Apps as Docker Containers\n.\n\n\nHow to Run Dockerized Applications?\n\n\nTo run REMnux-provided  application images, first you need to install Docker. This very easy to do on Linux (e.g. \nsudo apt-get install docker.io\n) and relatively painless on Windows and OS X. Just follow \nDocker\ns installation instructions\n for your operating system.\n\n\nOnce Docker is installed, you can run a Dockerized application by specifying the name of the desired app image. For example, to run the REMnux-provided image of \nThug\n, a low-interaction honeyclient, you would type something like \nsudo docker run --rm -it remnux/thug bash\n.\n\n\n\n\nDocker maintains the \nDocker Hub Registry\n of public application images. The \nREMnux repository\n of several malware analysis apps images is published there. For a listing of the available applications and guidelines for running them, see below.\n\n\nThe first time you run a Dockerized application, Docker will automatically download it from the Registry; your system will need to be connected to the Internet at that time. Afterwards, Docker will use a local copy of the image without relying on the Internet. If the application\ns image has been updated and you are connected to the Internet, Docker will automatically update your image when you run the app.\n\n\nHow Does Docker Work?\n\n\nDocker takes advantage of Linux kernels\n ability to run applications in containers, which are sometimes described as \nchroot on steroids.\n Containers provide each application an independent runtime environment, while avoiding the overhead of a full-fledged virtual machine.\n\n\nEach container gets its own virtual file system, process listing and network stack; however, containers share the OS kernel with each other and the underlying host. In this respect, the isolation provided by containers is less robust than that of real virtual machines, which have independent kernels and run on top of a hypervisor. Yet, sharing the kernel allows containers to run faster and offers management features that are difficult to accomplish with traditional virtualization.\n\n\nAn application distributed as a Docker image incorporates all the dependencies and configuration necessary for it to run, eliminating the need for end-users to install packages and troubleshoot dependencies. This approach allows developers to be certain that if the application worked in dev, it will work in production. Docker provides the tools necessary to build, run and manage applications packaged as Docker images.\n\n\nBenefits of Applications as Containers\n\n\nIn many cases, it is convenient to launch malware analysis tools the traditional way by running them directly on the OS, for instance taking advantage of the packages preinstalled as part of the \nREMnux distribution\n. Alternatively, you might want to run a tool without installing it directly onto your system, perhaps because you want to keep your system unclattered, or because it lacks the dependencies necessary to run the application.\n\n\nWhen running the app as a Docker container, you\nre able to take advantage of the image developer\ns efforts to figure out how to properly set up the application. Also, you get to benefit from any updates that the application\ns developer and the image maintainer introduces without having to worry how to install them.\n\n\nBecause Docker images are mostly independent of each other, you can run applications in environments separate from each other and the underlying system; this is especially useful when applications rely on conflicting dependencies. Because Docker containers are more lightweight than virtual machines, it\ns more practical to dedicate a container to a single app than trying to set up a VM per application.\n\n\nA Redhat article outlines \nadditional benefits that Docker offers\n, which include:\n\n\n\n\nRapid application deployment\n\n\nPortability across machines\n\n\nVersion control and component reuse\n\n\nSimplified maintenance\n\n\n\n\nLastly, those who are trying to install applications directly on their system without Docker can examine the Dockerfile config for the desired application to see explicit, scriptable instructions for installing the app into their own environment.\n\n\nDocker containers have their limitations and sometimes it\ns easier to run applications the traditional way. By providing Docker images several popular malware analysis tools, in addition to offering a full Linux distro, REMnux gives you the flexibility to investigate malicious software using several approaches.\n\n\nAvailable Application Images\n\n\nThe \nREMnux repository on the Docker Hub Registry\n lists the images of malware analysis applications available as part of the project. These apps include:\n\n\n\n\nGoogle\ns V8 JavaScript engine for JavaScript deobfuscation: \nremnux/v8\n\n\nThug low-interaction honeyclient: \nremnux/thug\n\n\nViper binary analysis and management framework:  \nremnux/viper\n\n\nRekall memory forensic framework:  \nremnux/rekall\n\n\nJSDetox JavaScript analysis tool for deobfuscation:  \nremnux/jsdetox\n\n\nRadare2 reverse-engineering framework and disassembler: \nremnux/radare2\n\n\nPescanner static malware analysis tool for Windows PE files: \nremnux/pescanner\n\n\nThe Volatility Framework for memory forensics: \nremnux/volatility\n\n\nMASTIFF static analysis framework for suspicious files: \nremnux/mastiff\n\n\nMaltrieve for retrieving malware samples: \nremnux/maltrieve\n\n\n\n\nFor more details about using these application images, please see \nRunning REMnux-Provided Images\n.\n\n\nHelp expand this collection! You can put together Dockerfile configs for building Docker images of malware analysis applications that are not yet present in the repository. To do this, follow the guidelines in the article \nCreating Docker Images for REMnux\n.", 
            "title": "Docker Images for Malware Analysis"
        }, 
        {
            "location": "/containers/malware-analysis/#how-to-run-dockerized-applications", 
            "text": "To run REMnux-provided  application images, first you need to install Docker. This very easy to do on Linux (e.g.  sudo apt-get install docker.io ) and relatively painless on Windows and OS X. Just follow  Docker s installation instructions  for your operating system.  Once Docker is installed, you can run a Dockerized application by specifying the name of the desired app image. For example, to run the REMnux-provided image of  Thug , a low-interaction honeyclient, you would type something like  sudo docker run --rm -it remnux/thug bash .   Docker maintains the  Docker Hub Registry  of public application images. The  REMnux repository  of several malware analysis apps images is published there. For a listing of the available applications and guidelines for running them, see below.  The first time you run a Dockerized application, Docker will automatically download it from the Registry; your system will need to be connected to the Internet at that time. Afterwards, Docker will use a local copy of the image without relying on the Internet. If the application s image has been updated and you are connected to the Internet, Docker will automatically update your image when you run the app.", 
            "title": "How to Run Dockerized Applications?"
        }, 
        {
            "location": "/containers/malware-analysis/#how-does-docker-work", 
            "text": "Docker takes advantage of Linux kernels  ability to run applications in containers, which are sometimes described as  chroot on steroids.  Containers provide each application an independent runtime environment, while avoiding the overhead of a full-fledged virtual machine.  Each container gets its own virtual file system, process listing and network stack; however, containers share the OS kernel with each other and the underlying host. In this respect, the isolation provided by containers is less robust than that of real virtual machines, which have independent kernels and run on top of a hypervisor. Yet, sharing the kernel allows containers to run faster and offers management features that are difficult to accomplish with traditional virtualization.  An application distributed as a Docker image incorporates all the dependencies and configuration necessary for it to run, eliminating the need for end-users to install packages and troubleshoot dependencies. This approach allows developers to be certain that if the application worked in dev, it will work in production. Docker provides the tools necessary to build, run and manage applications packaged as Docker images.", 
            "title": "How Does Docker Work?"
        }, 
        {
            "location": "/containers/malware-analysis/#benefits-of-applications-as-containers", 
            "text": "In many cases, it is convenient to launch malware analysis tools the traditional way by running them directly on the OS, for instance taking advantage of the packages preinstalled as part of the  REMnux distribution . Alternatively, you might want to run a tool without installing it directly onto your system, perhaps because you want to keep your system unclattered, or because it lacks the dependencies necessary to run the application.  When running the app as a Docker container, you re able to take advantage of the image developer s efforts to figure out how to properly set up the application. Also, you get to benefit from any updates that the application s developer and the image maintainer introduces without having to worry how to install them.  Because Docker images are mostly independent of each other, you can run applications in environments separate from each other and the underlying system; this is especially useful when applications rely on conflicting dependencies. Because Docker containers are more lightweight than virtual machines, it s more practical to dedicate a container to a single app than trying to set up a VM per application.  A Redhat article outlines  additional benefits that Docker offers , which include:   Rapid application deployment  Portability across machines  Version control and component reuse  Simplified maintenance   Lastly, those who are trying to install applications directly on their system without Docker can examine the Dockerfile config for the desired application to see explicit, scriptable instructions for installing the app into their own environment.  Docker containers have their limitations and sometimes it s easier to run applications the traditional way. By providing Docker images several popular malware analysis tools, in addition to offering a full Linux distro, REMnux gives you the flexibility to investigate malicious software using several approaches.", 
            "title": "Benefits of Applications as Containers"
        }, 
        {
            "location": "/containers/malware-analysis/#available-application-images", 
            "text": "The  REMnux repository on the Docker Hub Registry  lists the images of malware analysis applications available as part of the project. These apps include:   Google s V8 JavaScript engine for JavaScript deobfuscation:  remnux/v8  Thug low-interaction honeyclient:  remnux/thug  Viper binary analysis and management framework:   remnux/viper  Rekall memory forensic framework:   remnux/rekall  JSDetox JavaScript analysis tool for deobfuscation:   remnux/jsdetox  Radare2 reverse-engineering framework and disassembler:  remnux/radare2  Pescanner static malware analysis tool for Windows PE files:  remnux/pescanner  The Volatility Framework for memory forensics:  remnux/volatility  MASTIFF static analysis framework for suspicious files:  remnux/mastiff  Maltrieve for retrieving malware samples:  remnux/maltrieve   For more details about using these application images, please see  Running REMnux-Provided Images .  Help expand this collection! You can put together Dockerfile configs for building Docker images of malware analysis applications that are not yet present in the repository. To do this, follow the guidelines in the article  Creating Docker Images for REMnux .", 
            "title": "Available Application Images"
        }, 
        {
            "location": "/containers/run-apps/", 
            "text": "If you\nd like to run the tools below without installing the full REMnux Linux distro, you can use the REMnux collection of \nDocker Images for Malware Analysis\n. The following page explains which applications are available as images and how to run them, assuming you\nve installed Docker on your underlying host.\n\n\nOnce you\nve installed the desired image, as outlined below, you can update it by using the \ndocker pull\n command (e.g., \nsudo docker pull remnux/radare2\n). To update all locally-cached images, run:\n\n\nsudo docker images |cut -d' ' -f1 | grep -v REPOSITORY | xargs -I %s sudo docker pull %s\n\n\n\nAlso, whenever practical, the containers below run applications as a non-root user. If you wish to launch them with root privileges, simply specify the parameter \n-u root\n to the \nrun\n command. \n\n\nGoogle\ns V8 JavaScript Engine: remnux/v8\n\n\nGoogle\ns V8 JavaScript Engine\n can be useful for obfuscating JavaScript embedded in malicious browser pages and PDF files. The REMnux image of this application is available in the the Docker Hub Registry as \nremnux/v8\n.\n\n\n\n\nThe easiest way to use V8 is to invoke it by first running \nbash\n or another shell within its container, and then running the \nd8\n command:\n\n\nsudo docker run --rm -it remnux/v8 bash\n\n\n\nHowever, since you\nll probably want to provide some files for V8 to examine and get some files back, you will probably want to invoke Docker with the \n-v\n parameter to specify a shared directory that the container and the underlying host will be able to access:\n\n\nsudo docker run --rm -it -v ~/files:/home/nonroot/files remnux/v8 bash\n\n\n\nIn the example above, the ~/files directory will be shared between your host and the container. Before running the command above, make sure that ~/files exists and that its permissions are world-readable (i.e., \nchmod a+xwr\n).\n\n\nThe remnux/v8 image includes a file that defines several objects, methods and properties that malicious JavaScript scripts running in a standalone interpreter will require. This file is located within the container in the ~/objects.js location. You might need to modify it to address the needs of your sample.\n\n\nOnce in the container, you might want to invoke the V8 application using a command like this:\n\n\nd8 -f ~/objects.js ~/files/file.js\n\n\n\nThug Low-Interaction Honeyclient: remnux/thug\n\n\nThug\n low-interaction honeyclient can assist with the analysis of suspicious websites. The REMnux image of this application is available in the the Docker Hub Registry as \nremnux/thug\n.\n\n\n\n\nThe easiest way to use Thug is to invoke it by first running \nbash\n or another shell within its container, and then running the \n./thug.py\n command:\n\n\nsudo docker run --rm -it remnux/thug bash\n\n\n\nIf you will want to save the log files that Thug creates when assessing the designated website, you will want to invoke Docker with the \n-v\n parameter to specify a shared directory that the container and the underlying host will be able to access:\n\n\nsudo docker run --rm -it -v ~/logs:/home/thug/logs remnux/thug bash\n\n\n\nIn the example above, the ~/logs directory will be shared between your host and the container. Before running the command above, make sure that ~/logs exists and that its permissions are world-readable (i.e., \nchmod a+xwr\n). If you\nd like to share an additional directory (e.g., \nfiles\n), supply the mapping using another -v parameter such as \n-v ~/files:/home/thug/files\n and remember to make the directory on your host world-accessible.\n\n\nOnce in the container, you might want to invoke the Thug application using a command like this:\n\n\n./thug.py -F http://example.com\n\n\n\nThe \n-F\n parameter directs Thug to enable file logging, so it saves extracted artifacts to \nlogs\n and \nfiles\n directories.\n\n\nIf you want Thug to examine a single website and don\nt need an interactive shell, you could run its image like this:\n\n\nsudo docker run --rm -it -v ~/logs:/home/thug/logs remnux/thug ./thug.py -F http://example.com\n\n\n\nIn the example above, we launched the Thug image and specified that the command to run within it should be \n./thug.py -F http://example.com\n. We also directed Docker to share the underlying host\ns ~/log directory, which is where Thug saved the results of its analysis.\n\n\nViper Binary Analysis Framework: remnux/viper\n\n\nViper\n is \na binary management and analysis framework dedicated to malware and exploit researchers.\n It\ns useful to examine samples and maintain historical records about prior investigations. The REMnux image of this application is available in the the Docker Hub Registry as \nremnux/viper\n.\n\n\n\n\nOne way to launch Viper is to simply run its container:\n\n\nsudo docker run --rm -it remnux/viper\n\n\n\nThis will automatically launch the tool. Alternatively, you could start the container by first running \nbash\n or another shell in it, and then running the \n../viper/viper.py\n command with the desired parameters:\n\n\nsudo docker run --rm -it remnux/viper bash\n\n\n\nHowever, you\nll probably want to share a directory between the container and your underlying host, so that Viper can read your samples and save its analysis. To do this, invoke Docker with the \n-v\n parameter to specify a shared directory that the container and the underlying host will be able to access:\n\n\nsudo docker run --rm -it -v ~/viper-workdir:/home/nonroot/workdir remnux/viper\n\n\n\nIn the example above, the ~/viper-workdir directory will be shared between your host and the container. Before running the command above, make sure that ~/viper-workdir exists and that its permissions are world-readable (i.e., \nchmod a+xwr\n).\n\n\nRekall Memory Forensic Framework: remnux/rekall\n\n\nRekall\n is a collection of tools for the extraction and analysis of artifacts from memory images. The REMnux image of this application is available in the the Docker Hub Registry as \nremnux/rekall\n.\n\n\n\n\nOne way to launch Rekall is to start the container by first running \nbash\n or another shell in it, and then running the \nrekall\n command with the desired parameters:\n\n\nsudo docker run --rm -it remnux/rekall bash\n\n\n\nHowever, you\nll probably want to share a directory between the container and your underlying host, so that Rekall can read your memory image files and save its output. To do this, invoke Docker with the \n-v\n parameter to specify a shared directory that the container and the underlying host will be able to access:\n\n\nsudo docker run --rm -it -v ~/files:/home/nonroot/files remnux/rekall bash\n\n\n\nIn the example above, the ~/files directory will be shared between your host and the container. Before running the command above, make sure that ~/files exists and that its permissions are world-readable (i.e., \nchmod a+xwr\n).\n\n\nTo use Rekall\ns web console, instead of its command-line interface, invoke the container with the -p parameter to give your host access to the container\ns TCP port 8000 like this:\n\n\nsudo docker run --rm -it -p 8000:8000 -v ~/files:/home/nonroot/files remnux/rekall\n\n\n\nThen connect to http://localhost:8000 using a web browser from your underlying host. To stop the container running in this mode, press \nCtrl+C\n in its terminal window.\n\n\nJSDetox JavaScript Analysis Tool: remnux/jsdetox\n\n\nJSDetox\n is a web-based tool for analyzing and deobfuscating JavaScript. The REMnux image of this application is available in the the Docker Hub Registry as \nremnux/jsdetox\n.\n\n\n\n\nOne way to launch JSDetox, run its container like this:\n\n\nsudo docker run --rm -p 3000:3000 remnux/jsdetox\n\n\n\nThen connect to http://localhost:3000 using a web browser from your underlying host.\n\n\nTo stop the JSDetox container, run \nsudo docker ps -l\n on your host to obtain the container ID, then use the \nsudo docker stop\ncontainer-id` command and wait about a minute, where \ncontainer-id\n is the ID of the JSDetox container.\n\n\nHelp expand this collection! You can put together Dockerfile configs for building Docker images of malware analysis applications that are not yet present in the repository. To do this, follow the guidelines in the article \nCreating Docker Images for REMnux\n.\n\n\nRadare2 Reverse Engineering Framework: remnux/radare2\n\n\nRadare2\n is a reverse-engineering framework that includes a disassembler and other capabilities useful for analyzing malicious code. The REMnux image of this application is available in the the Docker Hub Registry as \nremnux/radare2\n.\n\n\n\n\nTo use Radare2, first run \nbash\n or another shell in its container and then specify the \nrd2\n command with the desired parameters. You\nll probably want to share a directory between the container and your underlying host, so that Radare2 can read your samples and save its output. To do this, invoke Docker with the \n-v\n parameter to specify a shared directory that the container and the underlying host will be able to access:\n\n\nsudo docker run --rm -it -v ~/workdir:/home/nonroot/workdir remnux/radare2 bash\n\n\n\nIn the example above, the ~/workdir directory will be shared between your host and the container. Before running the command above, make sure that ~/workdir exists and that its permissions are world-readable (i.e., \nchmod a+xwr\n).\n\n\nPescanner Static Malware Analysis Tool: remnux/pescanner\n\n\nPescaner\n is a static malware analysis tool for examining suspicious Windows PE files. It was created by created by \nMichael Ligh\n and distributed with the book \nMalware Analyst Cookbook\n. The REMnux collection uses the \nversion of this tool\n that was modified by \nGlenn P. Edwards Jr.\n to introduce \nimphash\n support.\n\n\n\n\nTo use pescanner, first run \nbash\n or another shell in its container and then specify the \npescanner\n command, followed by the path to the file you\nd like to examine. You\nll probably want to share a directory between the container and your underlying host, so that pescanner can access your samples. To do this, invoke Docker with the \n-v\n parameter to specify a shared directory that the container and the underlying host will be able to access:\n\n\nsudo docker run --rm -it -v ~/workdir:/home/nonroot/workdir remnux/pescanner bash\n\n\n\nIn the example above, the ~/workdir directory will be shared between your host and the container. Before running the command above, make sure that ~/workdir exists and that its permissions are world-readable (i.e., \nchmod a+xwr\n).\n\n\nThe Volatility Framework for Memory Forensics: remnux/volatility\n\n\nThe Volatility Framework\n for Memory Forensics is a set of libraries and modules for examining memory images for malware and forensic artifacts.\n\n\n\n\nTo use Volatility, first run  \nbash\n or another shell in its container and then specify the \nvol.py\n command with the desired parameters:\n\n\nsudo docker run --rm -it remnux/volatility bash\n\n\n\nHowever, you\nll probably want to share a directory between the container and your underlying host, so that Volatility can read your memory image files and save its output. To do this, invoke Docker with the \n-v\n parameter to specify a shared directory that the container and the underlying host will be able to access:\n\n\nsudo docker run --rm -it -v ~/memdumps:/home/nonroot/memdumps remnux/volatility bash\n\n\n\nIn the example above, the ~/memdumps directory will be shared between your host and the container. Before running the above, make sure that ~/memdumps exists and that all users have the ability to read from and write to that directory and its contents (i.e., \nchmod a+xwr\n).\n\n\nMASTIFF Static Analysis Framework: remnux/mastiff\n\n\nMASTIFF\n is a framework for automatically extracting key static properties from suspicious files.\n\n\n\n\nTo use MASTIFF, first run \nbash\n or another shell in its container and then specify the \nmas.py\n command with the appropriate parameters. You\nll probably want to share a directory between the container and your underlying host, so that MASTIFF can access your samples and provide your with analysis logs. To do this, invoke Docker with the \n-v\n parameter to specify a shared directory that the container and the underlying host will be able to access:\n\n\nsudo docker run --rm -it -v ~/mastiff-workdir:/home/nonroot/workdir remnux/mastiff\n\n\n\nIn the example above, the ~/mastiff-workdir directory will be shared between your host and the container. Before running the command above, make sure that ~/mastiff-workdir exists and that its permissions are world-readable (i.e., \nchmod a+xwr\n).\n\n\nMaltrieve Malware Samples Downloader: remnux/maltrieve\n\n\nMaltrieve\n is a tool for retrieving malware samples.\n\n\n\n\nTo launch the Maltrieve image, run the following command, replacing\n\n~/archive\n with the path to your working directory on the underlying host.\nThis is where the downloaded malware samples will be deposited.\n\n\nsudo docker run --rm -it -v ~/archive:/archive remnux/maltrieve\n\n\n\nThis will launch Maltrieve without any parameters, directing the tool to retrieve\nmalware samples and save them to the ~/archive directory.\n\n\nIf you wish to specify command-line parameters to Maltrieve, then launch it like this:\n\n\nsudo docker run --rm -it -v ~/archive:/archive remnux/maltrieve bash\n\n\n\nThis will launch the bash shell in the container, at which point you can run the command\n\nmaltrieve\n, specifying optional command-line parameters if you wish.\n\n\nIn the examples above, the ~/memdumps directory will be shared between your host and the container.  Before running the command, create ~/archive on your host and make it world-accessible\n(\nchmod a+xwr\n).", 
            "title": "Running REMnux-Provided Images"
        }, 
        {
            "location": "/containers/run-apps/#googles-v8-javascript-engine-remnuxv8", 
            "text": "Google s V8 JavaScript Engine  can be useful for obfuscating JavaScript embedded in malicious browser pages and PDF files. The REMnux image of this application is available in the the Docker Hub Registry as  remnux/v8 .   The easiest way to use V8 is to invoke it by first running  bash  or another shell within its container, and then running the  d8  command:  sudo docker run --rm -it remnux/v8 bash  However, since you ll probably want to provide some files for V8 to examine and get some files back, you will probably want to invoke Docker with the  -v  parameter to specify a shared directory that the container and the underlying host will be able to access:  sudo docker run --rm -it -v ~/files:/home/nonroot/files remnux/v8 bash  In the example above, the ~/files directory will be shared between your host and the container. Before running the command above, make sure that ~/files exists and that its permissions are world-readable (i.e.,  chmod a+xwr ).  The remnux/v8 image includes a file that defines several objects, methods and properties that malicious JavaScript scripts running in a standalone interpreter will require. This file is located within the container in the ~/objects.js location. You might need to modify it to address the needs of your sample.  Once in the container, you might want to invoke the V8 application using a command like this:  d8 -f ~/objects.js ~/files/file.js", 
            "title": "Google's V8 JavaScript Engine: remnux/v8"
        }, 
        {
            "location": "/containers/run-apps/#thug-low-interaction-honeyclient-remnuxthug", 
            "text": "Thug  low-interaction honeyclient can assist with the analysis of suspicious websites. The REMnux image of this application is available in the the Docker Hub Registry as  remnux/thug .   The easiest way to use Thug is to invoke it by first running  bash  or another shell within its container, and then running the  ./thug.py  command:  sudo docker run --rm -it remnux/thug bash  If you will want to save the log files that Thug creates when assessing the designated website, you will want to invoke Docker with the  -v  parameter to specify a shared directory that the container and the underlying host will be able to access:  sudo docker run --rm -it -v ~/logs:/home/thug/logs remnux/thug bash  In the example above, the ~/logs directory will be shared between your host and the container. Before running the command above, make sure that ~/logs exists and that its permissions are world-readable (i.e.,  chmod a+xwr ). If you d like to share an additional directory (e.g.,  files ), supply the mapping using another -v parameter such as  -v ~/files:/home/thug/files  and remember to make the directory on your host world-accessible.  Once in the container, you might want to invoke the Thug application using a command like this:  ./thug.py -F http://example.com  The  -F  parameter directs Thug to enable file logging, so it saves extracted artifacts to  logs  and  files  directories.  If you want Thug to examine a single website and don t need an interactive shell, you could run its image like this:  sudo docker run --rm -it -v ~/logs:/home/thug/logs remnux/thug ./thug.py -F http://example.com  In the example above, we launched the Thug image and specified that the command to run within it should be  ./thug.py -F http://example.com . We also directed Docker to share the underlying host s ~/log directory, which is where Thug saved the results of its analysis.", 
            "title": "Thug Low-Interaction Honeyclient: remnux/thug"
        }, 
        {
            "location": "/containers/run-apps/#viper-binary-analysis-framework-remnuxviper", 
            "text": "Viper  is  a binary management and analysis framework dedicated to malware and exploit researchers.  It s useful to examine samples and maintain historical records about prior investigations. The REMnux image of this application is available in the the Docker Hub Registry as  remnux/viper .   One way to launch Viper is to simply run its container:  sudo docker run --rm -it remnux/viper  This will automatically launch the tool. Alternatively, you could start the container by first running  bash  or another shell in it, and then running the  ../viper/viper.py  command with the desired parameters:  sudo docker run --rm -it remnux/viper bash  However, you ll probably want to share a directory between the container and your underlying host, so that Viper can read your samples and save its analysis. To do this, invoke Docker with the  -v  parameter to specify a shared directory that the container and the underlying host will be able to access:  sudo docker run --rm -it -v ~/viper-workdir:/home/nonroot/workdir remnux/viper  In the example above, the ~/viper-workdir directory will be shared between your host and the container. Before running the command above, make sure that ~/viper-workdir exists and that its permissions are world-readable (i.e.,  chmod a+xwr ).", 
            "title": "Viper Binary Analysis Framework: remnux/viper"
        }, 
        {
            "location": "/containers/run-apps/#rekall-memory-forensic-framework-remnuxrekall", 
            "text": "Rekall  is a collection of tools for the extraction and analysis of artifacts from memory images. The REMnux image of this application is available in the the Docker Hub Registry as  remnux/rekall .   One way to launch Rekall is to start the container by first running  bash  or another shell in it, and then running the  rekall  command with the desired parameters:  sudo docker run --rm -it remnux/rekall bash  However, you ll probably want to share a directory between the container and your underlying host, so that Rekall can read your memory image files and save its output. To do this, invoke Docker with the  -v  parameter to specify a shared directory that the container and the underlying host will be able to access:  sudo docker run --rm -it -v ~/files:/home/nonroot/files remnux/rekall bash  In the example above, the ~/files directory will be shared between your host and the container. Before running the command above, make sure that ~/files exists and that its permissions are world-readable (i.e.,  chmod a+xwr ).  To use Rekall s web console, instead of its command-line interface, invoke the container with the -p parameter to give your host access to the container s TCP port 8000 like this:  sudo docker run --rm -it -p 8000:8000 -v ~/files:/home/nonroot/files remnux/rekall  Then connect to http://localhost:8000 using a web browser from your underlying host. To stop the container running in this mode, press  Ctrl+C  in its terminal window.", 
            "title": "Rekall Memory Forensic Framework: remnux/rekall"
        }, 
        {
            "location": "/containers/run-apps/#jsdetox-javascript-analysis-tool-remnuxjsdetox", 
            "text": "JSDetox  is a web-based tool for analyzing and deobfuscating JavaScript. The REMnux image of this application is available in the the Docker Hub Registry as  remnux/jsdetox .   One way to launch JSDetox, run its container like this:  sudo docker run --rm -p 3000:3000 remnux/jsdetox  Then connect to http://localhost:3000 using a web browser from your underlying host.  To stop the JSDetox container, run  sudo docker ps -l  on your host to obtain the container ID, then use the  sudo docker stop container-id` command and wait about a minute, where  container-id  is the ID of the JSDetox container.  Help expand this collection! You can put together Dockerfile configs for building Docker images of malware analysis applications that are not yet present in the repository. To do this, follow the guidelines in the article  Creating Docker Images for REMnux .", 
            "title": "JSDetox JavaScript Analysis Tool: remnux/jsdetox"
        }, 
        {
            "location": "/containers/run-apps/#radare2-reverse-engineering-framework-remnuxradare2", 
            "text": "Radare2  is a reverse-engineering framework that includes a disassembler and other capabilities useful for analyzing malicious code. The REMnux image of this application is available in the the Docker Hub Registry as  remnux/radare2 .   To use Radare2, first run  bash  or another shell in its container and then specify the  rd2  command with the desired parameters. You ll probably want to share a directory between the container and your underlying host, so that Radare2 can read your samples and save its output. To do this, invoke Docker with the  -v  parameter to specify a shared directory that the container and the underlying host will be able to access:  sudo docker run --rm -it -v ~/workdir:/home/nonroot/workdir remnux/radare2 bash  In the example above, the ~/workdir directory will be shared between your host and the container. Before running the command above, make sure that ~/workdir exists and that its permissions are world-readable (i.e.,  chmod a+xwr ).", 
            "title": "Radare2 Reverse Engineering Framework: remnux/radare2"
        }, 
        {
            "location": "/containers/run-apps/#pescanner-static-malware-analysis-tool-remnuxpescanner", 
            "text": "Pescaner  is a static malware analysis tool for examining suspicious Windows PE files. It was created by created by  Michael Ligh  and distributed with the book  Malware Analyst Cookbook . The REMnux collection uses the  version of this tool  that was modified by  Glenn P. Edwards Jr.  to introduce  imphash  support.   To use pescanner, first run  bash  or another shell in its container and then specify the  pescanner  command, followed by the path to the file you d like to examine. You ll probably want to share a directory between the container and your underlying host, so that pescanner can access your samples. To do this, invoke Docker with the  -v  parameter to specify a shared directory that the container and the underlying host will be able to access:  sudo docker run --rm -it -v ~/workdir:/home/nonroot/workdir remnux/pescanner bash  In the example above, the ~/workdir directory will be shared between your host and the container. Before running the command above, make sure that ~/workdir exists and that its permissions are world-readable (i.e.,  chmod a+xwr ).", 
            "title": "Pescanner Static Malware Analysis Tool: remnux/pescanner"
        }, 
        {
            "location": "/containers/run-apps/#the-volatility-framework-for-memory-forensics-remnuxvolatility", 
            "text": "The Volatility Framework  for Memory Forensics is a set of libraries and modules for examining memory images for malware and forensic artifacts.   To use Volatility, first run   bash  or another shell in its container and then specify the  vol.py  command with the desired parameters:  sudo docker run --rm -it remnux/volatility bash  However, you ll probably want to share a directory between the container and your underlying host, so that Volatility can read your memory image files and save its output. To do this, invoke Docker with the  -v  parameter to specify a shared directory that the container and the underlying host will be able to access:  sudo docker run --rm -it -v ~/memdumps:/home/nonroot/memdumps remnux/volatility bash  In the example above, the ~/memdumps directory will be shared between your host and the container. Before running the above, make sure that ~/memdumps exists and that all users have the ability to read from and write to that directory and its contents (i.e.,  chmod a+xwr ).", 
            "title": "The Volatility Framework for Memory Forensics: remnux/volatility"
        }, 
        {
            "location": "/containers/run-apps/#mastiff-static-analysis-framework-remnuxmastiff", 
            "text": "MASTIFF  is a framework for automatically extracting key static properties from suspicious files.   To use MASTIFF, first run  bash  or another shell in its container and then specify the  mas.py  command with the appropriate parameters. You ll probably want to share a directory between the container and your underlying host, so that MASTIFF can access your samples and provide your with analysis logs. To do this, invoke Docker with the  -v  parameter to specify a shared directory that the container and the underlying host will be able to access:  sudo docker run --rm -it -v ~/mastiff-workdir:/home/nonroot/workdir remnux/mastiff  In the example above, the ~/mastiff-workdir directory will be shared between your host and the container. Before running the command above, make sure that ~/mastiff-workdir exists and that its permissions are world-readable (i.e.,  chmod a+xwr ).", 
            "title": "MASTIFF Static Analysis Framework: remnux/mastiff"
        }, 
        {
            "location": "/containers/run-apps/#maltrieve-malware-samples-downloader-remnuxmaltrieve", 
            "text": "Maltrieve  is a tool for retrieving malware samples.   To launch the Maltrieve image, run the following command, replacing ~/archive  with the path to your working directory on the underlying host.\nThis is where the downloaded malware samples will be deposited.  sudo docker run --rm -it -v ~/archive:/archive remnux/maltrieve  This will launch Maltrieve without any parameters, directing the tool to retrieve\nmalware samples and save them to the ~/archive directory.  If you wish to specify command-line parameters to Maltrieve, then launch it like this:  sudo docker run --rm -it -v ~/archive:/archive remnux/maltrieve bash  This will launch the bash shell in the container, at which point you can run the command maltrieve , specifying optional command-line parameters if you wish.  In the examples above, the ~/memdumps directory will be shared between your host and the container.  Before running the command, create ~/archive on your host and make it world-accessible\n( chmod a+xwr ).", 
            "title": "Maltrieve Malware Samples Downloader: remnux/maltrieve"
        }, 
        {
            "location": "/containers/create-docker-images/", 
            "text": "Please contribute to the \nREMnux\n collection of Docker images\n of malware analysis applications. You\nll get a chance to experiment with Docker, become a master at setting up an application of your choice and expand the set of tools that other professionals can conveniently run for examining malicious software.\n\n\nAs a starting point, read the REMnux page regarding \nDocker and the notion of containers\n. Also, familiarize yourself with the approaches to \nrunning images that have already been created\n as part of the REMnux project. Next, review the guidelines and examples below. Lastly, read Docker\ns documentation for \nbuilding images using a Dockerfile\n.\n\n\nDocumenting the Build Steps in Dockerfile\n\n\nA properly-formatted Dockerfile describes the steps necessary to build and configure your application inside a Docker container in a repeatable and unattended manner. To get a sense for the structure of such files, browse the \nREMnux repository of Dockerfiles on Github\n. To explain how to build such files, we\nll use the \nJSDetox Dockerfile\n as an example.\n\n\nThe beginning of your Dockerfile should include comments that state which application is included in the image, who created the app and where it can be obtained in a traditional form. The comments should explain how the use of the image should run it. For instance:\n\n\n# This Docker image encapsulates the JSDetox malware analysis tool by @sven_t\n# from http://www.relentless-coding.com/projects/jsdetox\n#\n# To run this image after installing Docker, use the following command:\n# sudo docker run --rm -p 3000:3000 remnux/jsdetox\n# Then, connect to http://localhost:3000 using your web browser.\n\n\n\nREMnux images use a minimal Docker image of Ubuntu 14.04 as a starting point, as designated by the \nFROM\n directive below. The \nMAINTAINER\n tag explains who created and/or maintains the Dockerfile:\n\n\nFROM ubuntu:14.04\nMAINTAINER Lenny Zeltser (@lennyzeltser, www.zeltser.com)\n\n\n\nThe \nRUN\n directive below tells Docker which commands to run  inside the container when building the image. Your Dockerfile file should include the \napt-get update\n command, followed by \napt-get install -y\n and a listing of the Ubuntu packages that the application requires. Remember that the starting point for the image is a minimal Ubuntu installation, so assume that a given package is not present unless you explicitly install it:\n\n\nUSER root\nRUN apt-get update \n apt-get install -y \\\n  git \\\n  ruby \\\n  ruby-dev \\\n  bundler \\\n  build-essential \n \\\n  rm -rf /var/lib/apt/lists/*\n\n\n\nThe \nUSER\n directive above makes sure that Docker will run the \napt-get\n commands as root. Note that the \nRUN\n command above links several commands together using \n and employs \n\\\n to break this sequence of commands into multiple lines for better readability. We\nre linking several commands in this manner to slightly minimize the size of the resulting Docker image file. This is also the reason why we include the \nrm\n command to get rid of the package listing.\n\n\nThe followng \nRUN\n directive sets up the non-root user creatively named \nnonroot\n, so that commands and applications that don\nt require root provileges have a more restricted environment within which to run. Note that just as before, we\nre using \n to string together multiple commands, separating lines with \n\\\n:\n\n\nRUN groupadd -r nonroot \n \\\n  useradd -r -g nonroot -d /home/nonroot -s /sbin/nologin -c \"Nonroot User\" nonroot \n \\\n  mkdir /home/nonroot \n \\\n  chown -R nonroot:nonroot /home/nonroot\n\n\n\nThe next set of directives tells Docker to start running commands using the newly-set up \nnonroot\n user, defines the working directory to match that user\ns home directory and retrieves the code for the application we\nre installing (JSDetox, in this case):\n\n\nUSER nonroot\nWORKDIR /home/nonroot\nRUN git clone https://github.com/svent/jsdetox.git\n\n\n\nThe following instructions will install the application using the \nbundle install\n command, according the JSDetox installation instructions. Note that these instructions need to run as root to have the ability to copy the application\ns files into protected locations:\n\n\nUSER root\nWORKDIR /home/nonroot/jsdetox\nRUN bundle install\n\n\n\nThe final set of directives below tells Docker to switch back to using the \nnonroot\n user and sets the working directory to the location from which JSDetox should be launched. It also specifies which command Docker should run when this image is launched without any parameters:\n\n\nUSER nonroot\nWORKDIR /home/nonroot/jsdetox\nCMD ./jsdetox -l $HOSTNAME 2\n/dev/null\n\n\n\nBy default, JSDetox listens on \nlocalhost\n. To give us the opportunity to connect to JSDetox from outside of its container, the command above launches the tool with the \n-l\n parameter and specifies the $HOSTNAME varilable. This environment variable is automatically defined to match the hostname that Docker will assign when this container runs, which will allow JSDetox to listen on the network interface accessible from our underlying host.\n\n\nBuilding the App Image from the Dockerfile\n\n\nYour underlying system will need to be connected to the Internet when you build the Docker image, so that it can retrieve the necessary files when installing the application. Also, you\nll need to understand what is involved in setting up the app, including knowing its dependencies and configuration nuances.\n\n\nIt\ns difficult to create a Dockerfile, such as the one we reviewed above, in one shot. Inevitably, some command will run in a manner that you don\nt expect, preventing the application from installing properly. Before documenting your steps in Dockerfile, consider launching the base ubuntu:14.04 container like this:\n\n\nsudo docker run --rm -it ubuntu:14.04 bash\n\n\n\nThen, manually type and write down the commands into the container\ns shell to install the desired application. Once you\nve validated that a specific sequence of commands works, start building a Dockerfile by adding your instructions one or two at a time to validate that they work as intended.\n\n\nOnce you\nve created a Dockerfile that contains the desired directives, go to the directory where the file is present and run the following command, where \nimage-name\n is he name you\nd like to assign to the image file you\nre building:\n\n\nsudo docker build -t=image-name .\n\n\n\nBuilding the image can take some time, depending on the speed of your system and Internet connection, as Docker downloads the necessary packages and, if appropriate, compiles code.\n\n\n\n\nAfter Docker builds the image, you can run it using the following command to get a shell in the container where your application has been installed:\n\n\nsudo docker run --rm -it image-name bash\n\n\n\nOf course, \nimage-name\n in the command above should correspond to the name you\nve assigned to the image. The \n--rm\n parameter in the command above directs Docker to automatically remove the container once it finishes running. This gets rid of any changes the application may have made to the local environment when it ran, but does not remove the cached image file that represents the app on your system. The \n-it\n parameter requests that Docker open an interactive session to the container and assign a pseudo-TTY to it so you can interact with it.\n\n\nOnce you have built and tested your Dockerfile, \nshare it with Lenny Zeltser\n, so he can review it and, if appropriate, incorporate your contribution into the REMnux repository \non Github\n and \non the Docker Hub Registry\n.\n\n\nFacilitating File System and Network Interactions\n\n\nThe container will be isolated from the host system: by default it will be able to communicate over the network in the outbound direction, but won\nt accept inbound traffic. Also, if the container is invoked with the \n--rm\n parameter, its contents will  disappear after it stops running. When building the image, you might need to anticipate the user\ns need to communicate with the app inside the container over the network or to pass files in and out of the container.\n\n\nAccessing Network Ports in the Container\n\n\nIn the JSDetox example above, the application listens on TCP port 3000. In its default configuration, JSDetox listens on localhost, which would make its port inaccessible from outside its Docker container. This is why we launched JSDetox with the \n-l $HOSTNAME\n parameter\nthis directed the application to listen on the network interface that could be accessed from outside the container.\n\n\nUnless the user explicitly requests access to the container\ns port when launching its image, no ports will be accessible from the underlying system. Fortunately, Docker allows us to use the \n-p\n parameter to specify that a specific port within the container should be accessible from outside the container. For example, to access JSDetox\n port 3000, the user needs to specify \n-p 3000:3000\n. This maps the container\ns port 3000 to the underlying host\ns port 3000, allowing the user to communicate with JSDetox by connecting to http://localhost:3000 using a web browser.\n\n\nSharing Files with the Container\n\n\nThere is no need to share files with JSDetox inside the container by using the file system, because this application interacts with the user through the web browser. In contrast, some files expect the user to provide input or share output via the file system. Docker supports the \n-v\n parameter to share a directory between the underlying host and the container.\n\n\nFor example, let\ns say we wanted to share a folder with the container running the \nRekall Memory Forensic Framework\n, which is \navailable from the REMnux Docker repository\n. If the memory image file that you\nd like to analyze is located on your underlying host in the ~/files directory, you could share that directory with the Rekall container by specifying \n-v ~/files:/home/nonroot/files\n when running the application\ns image:\n\n\nsudo docker run --rm -it -v ~/files:/home/nonroot/files remnux/rekall bash\n\n\n\nThis maps the local ~/files directory to the /home/nonroot/files directory inside the container. The Rekall image is built to run the user-designated command (e.g., \nbash\n) as the user \nnonroot\n. To ensure that the non-root user has access to the underlying hosts ~/files directory, the user of the app will need to make that directory world-accessible (i.e., \nchmod a+xwr ~/files\n) before launching the container.\n\n\nThe comments in the beginning of your Dockerfile should provide guidelines for how the image should be launched to ensure that the user can provide files and communicate with ports.", 
            "title": "Creating Docker Images for REMnux"
        }, 
        {
            "location": "/containers/create-docker-images/#documenting-the-build-steps-in-dockerfile", 
            "text": "A properly-formatted Dockerfile describes the steps necessary to build and configure your application inside a Docker container in a repeatable and unattended manner. To get a sense for the structure of such files, browse the  REMnux repository of Dockerfiles on Github . To explain how to build such files, we ll use the  JSDetox Dockerfile  as an example.  The beginning of your Dockerfile should include comments that state which application is included in the image, who created the app and where it can be obtained in a traditional form. The comments should explain how the use of the image should run it. For instance:  # This Docker image encapsulates the JSDetox malware analysis tool by @sven_t\n# from http://www.relentless-coding.com/projects/jsdetox\n#\n# To run this image after installing Docker, use the following command:\n# sudo docker run --rm -p 3000:3000 remnux/jsdetox\n# Then, connect to http://localhost:3000 using your web browser.  REMnux images use a minimal Docker image of Ubuntu 14.04 as a starting point, as designated by the  FROM  directive below. The  MAINTAINER  tag explains who created and/or maintains the Dockerfile:  FROM ubuntu:14.04\nMAINTAINER Lenny Zeltser (@lennyzeltser, www.zeltser.com)  The  RUN  directive below tells Docker which commands to run  inside the container when building the image. Your Dockerfile file should include the  apt-get update  command, followed by  apt-get install -y  and a listing of the Ubuntu packages that the application requires. Remember that the starting point for the image is a minimal Ubuntu installation, so assume that a given package is not present unless you explicitly install it:  USER root\nRUN apt-get update   apt-get install -y \\\n  git \\\n  ruby \\\n  ruby-dev \\\n  bundler \\\n  build-essential   \\\n  rm -rf /var/lib/apt/lists/*  The  USER  directive above makes sure that Docker will run the  apt-get  commands as root. Note that the  RUN  command above links several commands together using   and employs  \\  to break this sequence of commands into multiple lines for better readability. We re linking several commands in this manner to slightly minimize the size of the resulting Docker image file. This is also the reason why we include the  rm  command to get rid of the package listing.  The followng  RUN  directive sets up the non-root user creatively named  nonroot , so that commands and applications that don t require root provileges have a more restricted environment within which to run. Note that just as before, we re using   to string together multiple commands, separating lines with  \\ :  RUN groupadd -r nonroot   \\\n  useradd -r -g nonroot -d /home/nonroot -s /sbin/nologin -c \"Nonroot User\" nonroot   \\\n  mkdir /home/nonroot   \\\n  chown -R nonroot:nonroot /home/nonroot  The next set of directives tells Docker to start running commands using the newly-set up  nonroot  user, defines the working directory to match that user s home directory and retrieves the code for the application we re installing (JSDetox, in this case):  USER nonroot\nWORKDIR /home/nonroot\nRUN git clone https://github.com/svent/jsdetox.git  The following instructions will install the application using the  bundle install  command, according the JSDetox installation instructions. Note that these instructions need to run as root to have the ability to copy the application s files into protected locations:  USER root\nWORKDIR /home/nonroot/jsdetox\nRUN bundle install  The final set of directives below tells Docker to switch back to using the  nonroot  user and sets the working directory to the location from which JSDetox should be launched. It also specifies which command Docker should run when this image is launched without any parameters:  USER nonroot\nWORKDIR /home/nonroot/jsdetox\nCMD ./jsdetox -l $HOSTNAME 2 /dev/null  By default, JSDetox listens on  localhost . To give us the opportunity to connect to JSDetox from outside of its container, the command above launches the tool with the  -l  parameter and specifies the $HOSTNAME varilable. This environment variable is automatically defined to match the hostname that Docker will assign when this container runs, which will allow JSDetox to listen on the network interface accessible from our underlying host.", 
            "title": "Documenting the Build Steps in Dockerfile"
        }, 
        {
            "location": "/containers/create-docker-images/#building-the-app-image-from-the-dockerfile", 
            "text": "Your underlying system will need to be connected to the Internet when you build the Docker image, so that it can retrieve the necessary files when installing the application. Also, you ll need to understand what is involved in setting up the app, including knowing its dependencies and configuration nuances.  It s difficult to create a Dockerfile, such as the one we reviewed above, in one shot. Inevitably, some command will run in a manner that you don t expect, preventing the application from installing properly. Before documenting your steps in Dockerfile, consider launching the base ubuntu:14.04 container like this:  sudo docker run --rm -it ubuntu:14.04 bash  Then, manually type and write down the commands into the container s shell to install the desired application. Once you ve validated that a specific sequence of commands works, start building a Dockerfile by adding your instructions one or two at a time to validate that they work as intended.  Once you ve created a Dockerfile that contains the desired directives, go to the directory where the file is present and run the following command, where  image-name  is he name you d like to assign to the image file you re building:  sudo docker build -t=image-name .  Building the image can take some time, depending on the speed of your system and Internet connection, as Docker downloads the necessary packages and, if appropriate, compiles code.   After Docker builds the image, you can run it using the following command to get a shell in the container where your application has been installed:  sudo docker run --rm -it image-name bash  Of course,  image-name  in the command above should correspond to the name you ve assigned to the image. The  --rm  parameter in the command above directs Docker to automatically remove the container once it finishes running. This gets rid of any changes the application may have made to the local environment when it ran, but does not remove the cached image file that represents the app on your system. The  -it  parameter requests that Docker open an interactive session to the container and assign a pseudo-TTY to it so you can interact with it.  Once you have built and tested your Dockerfile,  share it with Lenny Zeltser , so he can review it and, if appropriate, incorporate your contribution into the REMnux repository  on Github  and  on the Docker Hub Registry .", 
            "title": "Building the App Image from the Dockerfile"
        }, 
        {
            "location": "/containers/create-docker-images/#facilitating-file-system-and-network-interactions", 
            "text": "The container will be isolated from the host system: by default it will be able to communicate over the network in the outbound direction, but won t accept inbound traffic. Also, if the container is invoked with the  --rm  parameter, its contents will  disappear after it stops running. When building the image, you might need to anticipate the user s need to communicate with the app inside the container over the network or to pass files in and out of the container.  Accessing Network Ports in the Container  In the JSDetox example above, the application listens on TCP port 3000. In its default configuration, JSDetox listens on localhost, which would make its port inaccessible from outside its Docker container. This is why we launched JSDetox with the  -l $HOSTNAME  parameter this directed the application to listen on the network interface that could be accessed from outside the container.  Unless the user explicitly requests access to the container s port when launching its image, no ports will be accessible from the underlying system. Fortunately, Docker allows us to use the  -p  parameter to specify that a specific port within the container should be accessible from outside the container. For example, to access JSDetox  port 3000, the user needs to specify  -p 3000:3000 . This maps the container s port 3000 to the underlying host s port 3000, allowing the user to communicate with JSDetox by connecting to http://localhost:3000 using a web browser.  Sharing Files with the Container  There is no need to share files with JSDetox inside the container by using the file system, because this application interacts with the user through the web browser. In contrast, some files expect the user to provide input or share output via the file system. Docker supports the  -v  parameter to share a directory between the underlying host and the container.  For example, let s say we wanted to share a folder with the container running the  Rekall Memory Forensic Framework , which is  available from the REMnux Docker repository . If the memory image file that you d like to analyze is located on your underlying host in the ~/files directory, you could share that directory with the Rekall container by specifying  -v ~/files:/home/nonroot/files  when running the application s image:  sudo docker run --rm -it -v ~/files:/home/nonroot/files remnux/rekall bash  This maps the local ~/files directory to the /home/nonroot/files directory inside the container. The Rekall image is built to run the user-designated command (e.g.,  bash ) as the user  nonroot . To ensure that the non-root user has access to the underlying hosts ~/files directory, the user of the app will need to make that directory world-accessible (i.e.,  chmod a+xwr ~/files ) before launching the container.  The comments in the beginning of your Dockerfile should provide guidelines for how the image should be launched to ensure that the user can provide files and communicate with ports.", 
            "title": "Facilitating File System and Network Interactions"
        }, 
        {
            "location": "/expand/contribute/", 
            "text": "Contribute Your Expertise\n\n\nREMnux\n is maintained by \nLenny Zeltser\n with extensive help from \nDavid Westcott\n. We could use your assistance! There are several ways in which you can also contribute to the project.\n\n\nDocumentation\n\n\nHelp create brief reference notes about the tools installed on the REMnux distro.\n\n\nPick a \ntool installed on REMnux\n, then confirm that it doesn\nt already have a page in the \ntools\n directory of the REMnux docs repo\n. Next, write a reference note about the tool by using the \ndocumentation template\n as a starting point. The page doesn\nt need to be a comprehensive document; instead, it should be a reference that helps REMnux users start using the tool. The note should be formatted according to the easy-to-use \nMarkdown syntax\n. Once you\nre done, send your doc to Lenny and David via \ndistro at remnux dot org\n.\n\n\nAnother way to contribute documentation to REMnux is to write a full article that explains how to use one of the tools installed on REMnux and send the link to distro at remnux dot org, so it can be listed in the \nUsing REMunux and Its Tools\n section of the site.\n\n\nDockerfile Configurations\n\n\nYou can also contribute to the REMnux project by creating Dockerfile configs for building Docker images of malware analysis applications that are not yet present in the \nREMnux Docker image collection\n. If you are new to Docker, you can learn how to \ndistribute and run apps inside containers\n and how to \nbuild your own images\n. Once you have built and tested your Dockerfile, \nshare it with Lenny Zeltser\n.\n\n\nIssues and Fixes\n\n\nIf you come across problems with tools available as part of REMnux, specially if you have suggestions for correcting the issues, please log them on the REMnux \ndistro repository\n or \nDockerfile repository\n on Github. You can also \nemail Lenny Zeltser\n.", 
            "title": "Contribute Your Expertise"
        }, 
        {
            "location": "/expand/contribute/#contribute-your-expertise", 
            "text": "REMnux  is maintained by  Lenny Zeltser  with extensive help from  David Westcott . We could use your assistance! There are several ways in which you can also contribute to the project.", 
            "title": "Contribute Your Expertise"
        }, 
        {
            "location": "/expand/contribute/#documentation", 
            "text": "Help create brief reference notes about the tools installed on the REMnux distro.  Pick a  tool installed on REMnux , then confirm that it doesn t already have a page in the  tools  directory of the REMnux docs repo . Next, write a reference note about the tool by using the  documentation template  as a starting point. The page doesn t need to be a comprehensive document; instead, it should be a reference that helps REMnux users start using the tool. The note should be formatted according to the easy-to-use  Markdown syntax . Once you re done, send your doc to Lenny and David via  distro at remnux dot org .  Another way to contribute documentation to REMnux is to write a full article that explains how to use one of the tools installed on REMnux and send the link to distro at remnux dot org, so it can be listed in the  Using REMunux and Its Tools  section of the site.", 
            "title": "Documentation"
        }, 
        {
            "location": "/expand/contribute/#dockerfile-configurations", 
            "text": "You can also contribute to the REMnux project by creating Dockerfile configs for building Docker images of malware analysis applications that are not yet present in the  REMnux Docker image collection . If you are new to Docker, you can learn how to  distribute and run apps inside containers  and how to  build your own images . Once you have built and tested your Dockerfile,  share it with Lenny Zeltser .", 
            "title": "Dockerfile Configurations"
        }, 
        {
            "location": "/expand/contribute/#issues-and-fixes", 
            "text": "If you come across problems with tools available as part of REMnux, specially if you have suggestions for correcting the issues, please log them on the REMnux  distro repository  or  Dockerfile repository  on Github. You can also  email Lenny Zeltser .", 
            "title": "Issues and Fixes"
        }
    ]
}