var tipuesearch = {
    "pages": [
        {
            "loc": "/",
            "tags": "",
            "text": "REMnux Documentation\n\n\nThis site provides  documentation for \nREMnux\n,\n a Linux toolkit for reverse-engineering and analyzing malware. REMnux strives to make it easier for forensic investigators and incident responders to start using the variety of freely-available tools that can examine malware, yet might be difficult to find or set up.\n\n\nThe heart of the project is the \nREMnux Linux distribution\n based on Ubuntu This lightweight distro incorporates many tools for analyzing Windows and Linux malware, examining browser-based threats such as obfuscated JavaScript, exploring suspicious document files and taking apart other malicious artifacts. Investigators can also use the distro to intercept suspicious network traffic in an isolated lab when performing behavioral malware analysis.\n\n\nAnother REMnux initiative involves building Docker \nimages of popular malware analysis tools\n. The goals of this effort is to allow investigators to conveniently utilize difficult-to-setup applications without having to install the REMnux distro. You can run Dockerized application containers as part of your existing environment.\n\n\nREMnux is maintained by \nLenny Zeltser\n with extensive help from \nDavid Westcott\n. You can learn the malware analysis techniques that make use of the tools installed and pre-configured on the REMnux distro by taking \nReverse-Engineering Malware training\n at SANS Institute.",
            "title": "Home"
        },
        {
            "loc": "/#remnux-documentation",
            "tags": "",
            "text": "This site provides  documentation for  REMnux ,  a Linux toolkit for reverse-engineering and analyzing malware. REMnux strives to make it easier for forensic investigators and incident responders to start using the variety of freely-available tools that can examine malware, yet might be difficult to find or set up.  The heart of the project is the  REMnux Linux distribution  based on Ubuntu This lightweight distro incorporates many tools for analyzing Windows and Linux malware, examining browser-based threats such as obfuscated JavaScript, exploring suspicious document files and taking apart other malicious artifacts. Investigators can also use the distro to intercept suspicious network traffic in an isolated lab when performing behavioral malware analysis.  Another REMnux initiative involves building Docker  images of popular malware analysis tools . The goals of this effort is to allow investigators to conveniently utilize difficult-to-setup applications without having to install the REMnux distro. You can run Dockerized application containers as part of your existing environment.  REMnux is maintained by  Lenny Zeltser  with extensive help from  David Westcott . You can learn the malware analysis techniques that make use of the tools installed and pre-configured on the REMnux distro by taking  Reverse-Engineering Malware training  at SANS Institute.",
            "title": "REMnux Documentation"
        },
        {
            "loc": "/distro/get/",
            "tags": "",
            "text": "The heart of the \nREMnux\n project is the REMnux Linux distribution based on \nUbuntu\n. This lightweight distro incorporates many tools for analyzing Windows and Linux malware, examining browser-based threats such as obfuscated JavaScript, exploring suspicious document files and taking apart other malicious artifacts. Investigators can also use the distro to intercept suspicious network traffic in an isolated lab when performing behavioral malware analysis.\n\n\nDownload the REMnux Distro\n\n\nYou can \ndownload the REMnux distribution\n as a virtual appliance archive and as an ISO image of a Live CD:\n\n\n\n\nOVF/OVA virtual appliance: \nremnux-5.0-ovf-public.ova\n for most virtualization tools, including VMware and VirtualBox (MD5 hash e5ab6981d1a4d5956b05ed525130d41f)\n\n\nVMware virtual appliance: \nremnux-5.0-vm-public.zip\n only for VMware virtualization softare and includes VMware Tools (MD5 hash 77ec0701661caceaa1a5eef90c0bacd1).\n\n\nISO image of a Live CD: \nremnux-5.0-live-cd.iso\n for ephemeral malware analysis sessions (MD5 hash a06b2603a13fba97f50818c2ab12bbe6).\n\n\n\n\nPrior to using the REMnux virtual appliance, you\nll need to obtain virtualization software such as \nVMware Player\n, \nVMware Workstation\n, \nVMware Fusion\n and \nVirtualBox\n.\n\n\nFor detailed instructions specific to the OVF/OVA version, see the article \nInstalling the REMnux Virtual Appliance for Malware Analysis\n. If using the OVF/OVA virtual appliance with VMware, you can optionally \ninstall VMware Tools in REMnux\n.\n\n\nIf you encounter problems installing REMnux, please see the tips, issues, errata and workarounds outlined in \nREMnux Version 5 Installation Notes\n.\n\n\nREMnux Distro Releases\n\n\nVersion 6 of REMnux is in the works and will be available in early 2015. It will be based on 64-bit \nUbuntu 14.04 LTS\n.\n\n\nThe latest release of the REMnux distro is version 5. It came out in May 2014. This release added new tools to the distribution and updated those that have been present the prior version. For more details related to REMnux v5, see \nits release announcement\n.\n\n\nVersion 4 of the REMnux distro \ncame out in April 2013\n. For details regarding REMnux v4, and to see the overview of the tools added to the distro as part of this release, \ntune into the recorded webcast on this topic\n.\n\n\nConnecting REMnux to the Internet\n\n\nThe REMnux virtual appliance is configured to use the \nhost-only\n network, isolating the REMnux instance from the physical network. To connect REMnux to the network, for instance, to provide it with Internet access, change the settings of the virtual appliance to the appropriate network, such as \nNAT\n then issue the \nrenew-dhcp\n command in REMnux.",
            "title": "Get the REMnux Distro"
        },
        {
            "loc": "/distro/get/#download-the-remnux-distro",
            "tags": "",
            "text": "You can  download the REMnux distribution  as a virtual appliance archive and as an ISO image of a Live CD:   OVF/OVA virtual appliance:  remnux-5.0-ovf-public.ova  for most virtualization tools, including VMware and VirtualBox (MD5 hash e5ab6981d1a4d5956b05ed525130d41f)  VMware virtual appliance:  remnux-5.0-vm-public.zip  only for VMware virtualization softare and includes VMware Tools (MD5 hash 77ec0701661caceaa1a5eef90c0bacd1).  ISO image of a Live CD:  remnux-5.0-live-cd.iso  for ephemeral malware analysis sessions (MD5 hash a06b2603a13fba97f50818c2ab12bbe6).   Prior to using the REMnux virtual appliance, you ll need to obtain virtualization software such as  VMware Player ,  VMware Workstation ,  VMware Fusion  and  VirtualBox .  For detailed instructions specific to the OVF/OVA version, see the article  Installing the REMnux Virtual Appliance for Malware Analysis . If using the OVF/OVA virtual appliance with VMware, you can optionally  install VMware Tools in REMnux .  If you encounter problems installing REMnux, please see the tips, issues, errata and workarounds outlined in  REMnux Version 5 Installation Notes .",
            "title": "Download the REMnux Distro"
        },
        {
            "loc": "/distro/get/#remnux-distro-releases",
            "tags": "",
            "text": "Version 6 of REMnux is in the works and will be available in early 2015. It will be based on 64-bit  Ubuntu 14.04 LTS .  The latest release of the REMnux distro is version 5. It came out in May 2014. This release added new tools to the distribution and updated those that have been present the prior version. For more details related to REMnux v5, see  its release announcement .  Version 4 of the REMnux distro  came out in April 2013 . For details regarding REMnux v4, and to see the overview of the tools added to the distro as part of this release,  tune into the recorded webcast on this topic .",
            "title": "REMnux Distro Releases"
        },
        {
            "loc": "/distro/get/#connecting-remnux-to-the-internet",
            "tags": "",
            "text": "The REMnux virtual appliance is configured to use the  host-only  network, isolating the REMnux instance from the physical network. To connect REMnux to the network, for instance, to provide it with Internet access, change the settings of the virtual appliance to the appropriate network, such as  NAT  then issue the  renew-dhcp  command in REMnux.",
            "title": "Connecting REMnux to the Internet"
        },
        {
            "loc": "/distro/tools/",
            "tags": "",
            "text": "The REMnux\n distribution includes many free tools useful for examining malicious software. These utilities are set up and tested to make it easier for you to perform malware analysis tasks without needing to figure out how to install them. The majority of these tools are listed below.\n\n\nFor more details, including each tool\ns description, see the REMnux v5 Tools \nmind map in the Xmind format\n or as a \nspreadsheet\n. \nPDF of the mind map\n is also available.\n\n\nExamine Browser Malware\n\n\n\n\nWebsite analysis: \nThug\n, \nmitmproxy\n, \nNetwork Miner Free Edition\n, \ncurl\n, \nWget\n, \nFirefox\n, \nBurp Proxy Free Edition\n, \nAutomater\n, pdnstool, \nMalzilla\n, \nTor\n\n\nFlash: \nxxxswf\n, \nSWF Tools\n, \nRABCDAsm\n, \nextract_swf\n\n\nJava: \nJava Cache IDX Parser\n, \nJava Decompiler\n\n\nJavaScript: \nRhino Debugger\n, \nJSDetox\n, \nExtractScripts\n, \nFirebug\n, \nJavaScript Deobfuscator\n, \nSpiderMonkey\n, \nV8\n, \nJS Beautifier\n, also shellcode tools below\n\n\n\n\nExamine Document Files\n\n\n\n\nPDF: \nAnalyzePDF\n, \nJSDetox\n, \nPdfobjflow\n, \npdfid\n, \npdf-parser\n, \npeepdf\n, \nOrigami\n, \nPDF X-RAY Lite\n, \nPDFtk\n; also JavaScript tools above\n\n\nMicrosoft Office: \nofficeparser\n, \nOfficeMalScanner\n\n\nShellcode: \nsctest\n, unicode2hex-escaped, unicode2raw, \ndism-this\n\n\n\n\nExtract and Decode Artifacts\n\n\n\n\nDeobfuscate: \nunXOR\n, \nXORStrings\n, \nex_pe_xor\n, \nXORSearch\n, \nbrutexor/iheartxor\n, \nxortool\n, \nNoMoreXOR\n, \nXORBruteForcer\n, \nBalbuzard\n\n\nExtract strings: \nstrdeobj\n, \npestr\n, \nstrings\n\n\nCarving: \nForemost\n, \nScalpel\n, \nbulk_extractor\n, \nHachoir\n\n\n\n\nHandle Network Interactions\n\n\n\n\nSniffing: \nWireshark\n, \nngrep\n, \nTCPDump\n, \ntcpick\n\n\nServices: \nFakeDNS\n, \nTiny HTTPd\n, \nfakeMail\n, \nHoneyd\n, \nINetSim\n, \nInspire IRCd\n, \nOpenSSH\n\n\nMiscellaneous network: \nprettyping.sh\n, set-static-ip, renew-dhcp, \nNetcat\n, \nEPIC IRC Client\n, \nstunnel\n\n\n\n\nProcess Multiple Samples\n\n\n\n\nMaltrieve\n, \nRagpicker\n, \nViper\n, \nMASTIFF\n, \nDensity Scout\n\n\n\n\nExamine File Properties and Contents\n\n\n\n\nDefine signatures: \nYaraGenerator\n, \nYara Editor\n, \nIOCextractor\n, \nAutorule\n\n\nScan: \nYara\n, \nClamAV\n, \nTrID\n, \nExifTool\n\n\nHashes: \nnsrllookup\n, \nAutomater\n, \nHash Identifier\n, \ntotalhash\n, \nssdeep\n\n\n\n\nInvestigate Linux Malware\n\n\n\n\nSystem: \nSysdig\n, \nUnhide\n\n\nDisassemble: \nVivisect\n, \nUdis86\n, \nobjdump\n\n\nDebug: \nEvan\ns Debugger (EDB)\n, \nGNU Project Debugger (GDB)\n\n\nTrace: \nstrace\n, \nltrace\n\n\nInvestigate: \nRadare 2\n, \nPyew\n, \nBokken\n\n\n\n\nEdit and View Files\n\n\n\n\nText: \nSciTE\n\n\nImages: \nfeh\n, \nImageMagick\n\n\nBinary: \nwxHexEditor\n, \nVBinDiff\n\n\nDocuments: \nXpdf\n, \nXMind\n\n\n\n\nExamine Memory Snapshots\n\n\n\n\nVolatility Framework\n, \nTotalRecall\n, \nfindaes\n, AESKeyFinder, RSAKeyFinder\n\n\n\n\nStatically Examine PE Files\n\n\n\n\nUnpacking: \nUPX\n, \nBytehist\n, \nDensity Scout\n, \nPackerID\n\n\nDisassemble: \nobjdump\n, \nUdis86\n, \nVivisect\n\n\nFind anomalies: \nSignsrch\n, \npescanner\n, \nExeScan\n, \npev\n, \nPeframe\n\n\nInvestigate: \nBokken\n, \nRATDecoders\n, \nPyew\n\n\n\n\nPerform Other Tasks\n\n\n\n\nProcDOT\n, \nbashhacks\n, \nAndrowarn\n\n\n\n\nInstall Additional Tools\n\n\nMetasploit\n is not installed on REMnux; however, \nyou can install it yourself\n if the need arises.\n\n\nWIPSTER\n offers a web-based interface to several REMnux tools. You can easily install WIPSTER on REMnux by running the command \n/usr/local/sbin/install-wipster\n.\n\n\nvtTool\n offers a convenient way of determining the likely name of malware by querying VirusTotal using the file\ns hash via the command line. To install it on REMnux after connecting the REMnux system to the Internet, run the following commands:\n\n\nsudo apt-get -y install python-numpy python-scipy python-levenshtein\nsudo pip install fuzzywuzzy scikit-learn\nwget https://malware-crawler.googlecode.com/svn/MalwareCrawler/src/tools/vtTool.py\nchmod a+xr vtTool.py\nsudo mv vtTool.py /usr/local/bin",
            "title": "Tools Installed on REMnux"
        },
        {
            "loc": "/distro/tools/#examine-browser-malware",
            "tags": "",
            "text": "Website analysis:  Thug ,  mitmproxy ,  Network Miner Free Edition ,  curl ,  Wget ,  Firefox ,  Burp Proxy Free Edition ,  Automater , pdnstool,  Malzilla ,  Tor  Flash:  xxxswf ,  SWF Tools ,  RABCDAsm ,  extract_swf  Java:  Java Cache IDX Parser ,  Java Decompiler  JavaScript:  Rhino Debugger ,  JSDetox ,  ExtractScripts ,  Firebug ,  JavaScript Deobfuscator ,  SpiderMonkey ,  V8 ,  JS Beautifier , also shellcode tools below",
            "title": "Examine Browser Malware"
        },
        {
            "loc": "/distro/tools/#examine-document-files",
            "tags": "",
            "text": "PDF:  AnalyzePDF ,  JSDetox ,  Pdfobjflow ,  pdfid ,  pdf-parser ,  peepdf ,  Origami ,  PDF X-RAY Lite ,  PDFtk ; also JavaScript tools above  Microsoft Office:  officeparser ,  OfficeMalScanner  Shellcode:  sctest , unicode2hex-escaped, unicode2raw,  dism-this",
            "title": "Examine Document Files"
        },
        {
            "loc": "/distro/tools/#extract-and-decode-artifacts",
            "tags": "",
            "text": "Deobfuscate:  unXOR ,  XORStrings ,  ex_pe_xor ,  XORSearch ,  brutexor/iheartxor ,  xortool ,  NoMoreXOR ,  XORBruteForcer ,  Balbuzard  Extract strings:  strdeobj ,  pestr ,  strings  Carving:  Foremost ,  Scalpel ,  bulk_extractor ,  Hachoir",
            "title": "Extract and Decode Artifacts"
        },
        {
            "loc": "/distro/tools/#handle-network-interactions",
            "tags": "",
            "text": "Sniffing:  Wireshark ,  ngrep ,  TCPDump ,  tcpick  Services:  FakeDNS ,  Tiny HTTPd ,  fakeMail ,  Honeyd ,  INetSim ,  Inspire IRCd ,  OpenSSH  Miscellaneous network:  prettyping.sh , set-static-ip, renew-dhcp,  Netcat ,  EPIC IRC Client ,  stunnel",
            "title": "Handle Network Interactions"
        },
        {
            "loc": "/distro/tools/#process-multiple-samples",
            "tags": "",
            "text": "Maltrieve ,  Ragpicker ,  Viper ,  MASTIFF ,  Density Scout",
            "title": "Process Multiple Samples"
        },
        {
            "loc": "/distro/tools/#examine-file-properties-and-contents",
            "tags": "",
            "text": "Define signatures:  YaraGenerator ,  Yara Editor ,  IOCextractor ,  Autorule  Scan:  Yara ,  ClamAV ,  TrID ,  ExifTool  Hashes:  nsrllookup ,  Automater ,  Hash Identifier ,  totalhash ,  ssdeep",
            "title": "Examine File Properties and Contents"
        },
        {
            "loc": "/distro/tools/#investigate-linux-malware",
            "tags": "",
            "text": "System:  Sysdig ,  Unhide  Disassemble:  Vivisect ,  Udis86 ,  objdump  Debug:  Evan s Debugger (EDB) ,  GNU Project Debugger (GDB)  Trace:  strace ,  ltrace  Investigate:  Radare 2 ,  Pyew ,  Bokken",
            "title": "Investigate Linux Malware"
        },
        {
            "loc": "/distro/tools/#edit-and-view-files",
            "tags": "",
            "text": "Text:  SciTE  Images:  feh ,  ImageMagick  Binary:  wxHexEditor ,  VBinDiff  Documents:  Xpdf ,  XMind",
            "title": "Edit and View Files"
        },
        {
            "loc": "/distro/tools/#examine-memory-snapshots",
            "tags": "",
            "text": "Volatility Framework ,  TotalRecall ,  findaes , AESKeyFinder, RSAKeyFinder",
            "title": "Examine Memory Snapshots"
        },
        {
            "loc": "/distro/tools/#statically-examine-pe-files",
            "tags": "",
            "text": "Unpacking:  UPX ,  Bytehist ,  Density Scout ,  PackerID  Disassemble:  objdump ,  Udis86 ,  Vivisect  Find anomalies:  Signsrch ,  pescanner ,  ExeScan ,  pev ,  Peframe  Investigate:  Bokken ,  RATDecoders ,  Pyew",
            "title": "Statically Examine PE Files"
        },
        {
            "loc": "/distro/tools/#perform-other-tasks",
            "tags": "",
            "text": "ProcDOT ,  bashhacks ,  Androwarn",
            "title": "Perform Other Tasks"
        },
        {
            "loc": "/distro/tools/#install-additional-tools",
            "tags": "",
            "text": "Metasploit  is not installed on REMnux; however,  you can install it yourself  if the need arises.  WIPSTER  offers a web-based interface to several REMnux tools. You can easily install WIPSTER on REMnux by running the command  /usr/local/sbin/install-wipster .  vtTool  offers a convenient way of determining the likely name of malware by querying VirusTotal using the file s hash via the command line. To install it on REMnux after connecting the REMnux system to the Internet, run the following commands:  sudo apt-get -y install python-numpy python-scipy python-levenshtein\nsudo pip install fuzzywuzzy scikit-learn\nwget https://malware-crawler.googlecode.com/svn/MalwareCrawler/src/tools/vtTool.py\nchmod a+xr vtTool.py\nsudo mv vtTool.py /usr/local/bin",
            "title": "Install Additional Tools"
        },
        {
            "loc": "/distro/use/",
            "tags": "",
            "text": "This section will contain documentation about the tools installed on the REMnux\n distro. Would you like to \ncontribute your insights on REMnux and its tools\n to expand this document set?\n\n\nRecorded REMnux Webcasts\n\n\nTo get started with the REMnux distro and become familiar with some of its tools, tune into the following recorded webcasts:\n\n\n\n\nMalware Analysis Essentials Using REMnux\n\n\nWhat\ns New in REMnux v4\n\n\n\n\nREMnux Cheat Sheet\n\n\nThe one-page \nREMnux cheat sheet\n provides a reasonable reference if you are new to REMnux. Also, the \nXmind-formatted mind map\n of the tools that comprise the distro include brief references for each tool and a tip for how to launch it.",
            "title": "Using REMnux and Its Tools"
        },
        {
            "loc": "/distro/use/#recorded-remnux-webcasts",
            "tags": "",
            "text": "To get started with the REMnux distro and become familiar with some of its tools, tune into the following recorded webcasts:   Malware Analysis Essentials Using REMnux  What s New in REMnux v4",
            "title": "Recorded REMnux Webcasts"
        },
        {
            "loc": "/distro/use/#remnux-cheat-sheet",
            "tags": "",
            "text": "The one-page  REMnux cheat sheet  provides a reasonable reference if you are new to REMnux. Also, the  Xmind-formatted mind map  of the tools that comprise the distro include brief references for each tool and a tip for how to launch it.",
            "title": "REMnux Cheat Sheet"
        },
        {
            "loc": "/containers/malware-analysis/",
            "tags": "",
            "text": "One aspect of the REMnux\n project involves providing \nDocker\n images of popular malware analysis tools, with the goal of allowing investigators to conveniently utilize difficult-to-install applications without having to install the REMnux distro. Such images could be compared to lightweight virtual machines; though they don\nt offer the same level of isolation as real VMs, they provide a container within which the application can be encapsulated along with its dependencies.\n\n\nSee documentation below for more information and tune into the recorded webcast \nHow to Run Linux Malware Analysis Apps as Docker Containers\n.\n\n\nHow to Run Dockerized Applications?\n\n\nTo run REMnux-provided  application images, first you need to install Docker. This very easy to do on Linux (e.g. \nsudo apt-get install docker.io\n) and relatively painless on Windows and OS X. Just follow \nDocker\ns installation instructions\n for your operating system.\n\n\nOnce Docker is installed, you can run a Dockerized application by specifying the name of the desired app image. For example, to run the REMnux-provided image of \nThug\n, a low-interaction honeyclient, you would type something like \nsudo docker run --rm -it remnux/thug bash\n.\n\n\n\n\nDocker maintains the \nDocker Hub Registry\n of public application images. The \nREMnux repository\n of several malware analysis apps images is published there. For a listing of the available applications and guidelines for running them, see below.\n\n\nThe first time you run a Dockerized application, Docker will automatically download it from the Registry; your system will need to be connected to the Internet at that time. Afterwards, Docker will use a local copy of the image without relying on the Internet. If the application\ns image has been updated and you are connected to the Internet, Docker will automatically update your image when you run the app.\n\n\nHow Does Docker Work?\n\n\nDocker takes advantage of Linux kernels\n ability to run applications in containers, which are sometimes described as \nchroot on steroids.\n Containers provide each application an independent runtime environment, while avoiding the overhead of a full-fledged virtual machine.\n\n\nEach container gets its own virtual file system, process listing and network stack; however, containers share the OS kernel with each other and the underlying host. In this respect, the isolation provided by containers is less robust than that of real virtual machines, which have independent kernels and run on top of a hypervisor. Yet, sharing the kernel allows containers to run faster and offers management features that are difficult to accomplish with traditional virtualization.\n\n\nAn application distributed as a Docker image incorporates all the dependencies and configuration necessary for it to run, eliminating the need for end-users to install packages and troubleshoot dependencies. This approach allows developers to be certain that if the application worked in dev, it will work in production. Docker provides the tools necessary to build, run and manage applications packaged as Docker images.\n\n\nBenefits of Applications as Containers\n\n\nIn many cases, it is convenient to launch malware analysis tools the traditional way by running them directly on the OS, for instance taking advantage of the packages preinstalled as part of the \nREMnux distribution\n. Alternatively, you might want to run a tool without installing it directly onto your system, perhaps because you want to keep your system unclattered, or because it lacks the dependencies necessary to run the application.\n\n\nWhen running the app as a Docker container, you\nre able to take advantage of the image developer\ns efforts to figure out how to properly set up the application. Also, you get to benefit from any updates that the application\ns developer and the image maintainer introduces without having to worry how to install them.\n\n\nBecause Docker images are mostly independent of each other, you can run applications in environments separate from each other and the underlying system; this is especially useful when applications rely on conflicting dependencies. Because Docker containers are more lightweight than virtual machines, it\ns more practical to dedicate a container to a single app than trying to set up a VM per application.\n\n\nA Redhat article outlines \nadditional benefits that Docker offers\n, which include:\n\n\n\n\nRapid application deployment\n\n\nPortability across machines\n\n\nVersion control and component reuse\n\n\nSimplified maintenance\n\n\n\n\nLastly, those who are trying to install applications directly on their system without Docker can examine the Dockerfile config for the desired application to see explicit, scriptable instructions for installing the app into their own environment.\n\n\nDocker containers have their limitations and sometimes it\ns easier to run applications the traditional way. By providing Docker images several popular malware analysis tools, in addition to offering a full Linux distro, REMnux gives you the flexibility to investigate malicious software using several approaches.\n\n\nAvailable Application Images\n\n\nThe \nREMnux repository on the Docker Hub Registry\n lists the images of malware analysis applications available as part of the project. These apps include:\n\n\n\n\nGoogle\ns V8 JavaScript engine for JavaScript deobfuscation: \nremnux/v8\n\n\nThug low-interaction honeyclient: \nremnux/thug\n\n\nViper binary analysis and management framework:  \nremnux/viper\n\n\nRekall memory forensic framework:  \nremnux/rekall\n\n\nJSDetox JavaScript analysis tool for deobfuscation:  \nremnux/jsdetox\n\n\nRadare2 reverse-engineering framework and disassembler: \nremnux/radare2\n\n\nPescanner static malware analysis tool for Windows PE files: \nremnux/pescanner\n\n\n\n\nFor more details about using these application images, please see \nRunning REMnux-Provided Images\n.\n\n\nHelp expand this collection! You can put together Dockerfile configs for building Docker images of malware analysis applications that are not yet present in the repository. To do this, follow the guidelines in the article \nCreating Docker Images for REMnux\n.",
            "title": "Docker Images for Malware Analysis"
        },
        {
            "loc": "/containers/malware-analysis/#how-to-run-dockerized-applications",
            "tags": "",
            "text": "To run REMnux-provided  application images, first you need to install Docker. This very easy to do on Linux (e.g.  sudo apt-get install docker.io ) and relatively painless on Windows and OS X. Just follow  Docker s installation instructions  for your operating system.  Once Docker is installed, you can run a Dockerized application by specifying the name of the desired app image. For example, to run the REMnux-provided image of  Thug , a low-interaction honeyclient, you would type something like  sudo docker run --rm -it remnux/thug bash .   Docker maintains the  Docker Hub Registry  of public application images. The  REMnux repository  of several malware analysis apps images is published there. For a listing of the available applications and guidelines for running them, see below.  The first time you run a Dockerized application, Docker will automatically download it from the Registry; your system will need to be connected to the Internet at that time. Afterwards, Docker will use a local copy of the image without relying on the Internet. If the application s image has been updated and you are connected to the Internet, Docker will automatically update your image when you run the app.",
            "title": "How to Run Dockerized Applications?"
        },
        {
            "loc": "/containers/malware-analysis/#how-does-docker-work",
            "tags": "",
            "text": "Docker takes advantage of Linux kernels  ability to run applications in containers, which are sometimes described as  chroot on steroids.  Containers provide each application an independent runtime environment, while avoiding the overhead of a full-fledged virtual machine.  Each container gets its own virtual file system, process listing and network stack; however, containers share the OS kernel with each other and the underlying host. In this respect, the isolation provided by containers is less robust than that of real virtual machines, which have independent kernels and run on top of a hypervisor. Yet, sharing the kernel allows containers to run faster and offers management features that are difficult to accomplish with traditional virtualization.  An application distributed as a Docker image incorporates all the dependencies and configuration necessary for it to run, eliminating the need for end-users to install packages and troubleshoot dependencies. This approach allows developers to be certain that if the application worked in dev, it will work in production. Docker provides the tools necessary to build, run and manage applications packaged as Docker images.",
            "title": "How Does Docker Work?"
        },
        {
            "loc": "/containers/malware-analysis/#benefits-of-applications-as-containers",
            "tags": "",
            "text": "In many cases, it is convenient to launch malware analysis tools the traditional way by running them directly on the OS, for instance taking advantage of the packages preinstalled as part of the  REMnux distribution . Alternatively, you might want to run a tool without installing it directly onto your system, perhaps because you want to keep your system unclattered, or because it lacks the dependencies necessary to run the application.  When running the app as a Docker container, you re able to take advantage of the image developer s efforts to figure out how to properly set up the application. Also, you get to benefit from any updates that the application s developer and the image maintainer introduces without having to worry how to install them.  Because Docker images are mostly independent of each other, you can run applications in environments separate from each other and the underlying system; this is especially useful when applications rely on conflicting dependencies. Because Docker containers are more lightweight than virtual machines, it s more practical to dedicate a container to a single app than trying to set up a VM per application.  A Redhat article outlines  additional benefits that Docker offers , which include:   Rapid application deployment  Portability across machines  Version control and component reuse  Simplified maintenance   Lastly, those who are trying to install applications directly on their system without Docker can examine the Dockerfile config for the desired application to see explicit, scriptable instructions for installing the app into their own environment.  Docker containers have their limitations and sometimes it s easier to run applications the traditional way. By providing Docker images several popular malware analysis tools, in addition to offering a full Linux distro, REMnux gives you the flexibility to investigate malicious software using several approaches.",
            "title": "Benefits of Applications as Containers"
        },
        {
            "loc": "/containers/malware-analysis/#available-application-images",
            "tags": "",
            "text": "The  REMnux repository on the Docker Hub Registry  lists the images of malware analysis applications available as part of the project. These apps include:   Google s V8 JavaScript engine for JavaScript deobfuscation:  remnux/v8  Thug low-interaction honeyclient:  remnux/thug  Viper binary analysis and management framework:   remnux/viper  Rekall memory forensic framework:   remnux/rekall  JSDetox JavaScript analysis tool for deobfuscation:   remnux/jsdetox  Radare2 reverse-engineering framework and disassembler:  remnux/radare2  Pescanner static malware analysis tool for Windows PE files:  remnux/pescanner   For more details about using these application images, please see  Running REMnux-Provided Images .  Help expand this collection! You can put together Dockerfile configs for building Docker images of malware analysis applications that are not yet present in the repository. To do this, follow the guidelines in the article  Creating Docker Images for REMnux .",
            "title": "Available Application Images"
        },
        {
            "loc": "/containers/run-apps/",
            "tags": "",
            "text": "If you\nd like to run the tools below without installing the full REMnux Linux distro, you can use the REMnux collection of \nDocker Images for Malware Analysis\n. The following page explains which applications are available as images and how to run them, assuming you\nve installed Docker on your underlying host.\n\n\nOnce you\nve installed the desired image, as outlined below, you can update it by using the \ndocker pull\n command (e.g., \nsudo docker pull remnux/radare2\n). To update all locally-cached images, run:\n\n\nsudo docker images |cut -d' ' -f1 | grep -v REPOSITORY | xargs -I %s sudo docker pull %s\n\n\n\nGoogle\ns V8 JavaScript Engine: remnux/v8\n\n\nGoogle\ns V8 JavaScript Engine\n can be useful for obfuscating JavaScript embedded in malicious browser pages and PDF files. The REMnux image of this application is available in the the Docker Hub Registry as \nremnux/v8\n.\n\n\n\n\nThe easiest way to use V8 is to invoke it by first running \nbash\n or another shell within its container, and then running the \nd8\n command:\n\n\nsudo docker run --rm -it remnux/v8 bash\n\n\n\nHowever, since you\nll probably want to provide some files for V8 to examine and get some files back, you will probably want to invoke Docker with the \n-v\n parameter to specify a shared directory that the container and the underlying host will be able to access:\n\n\nsudo docker run --rm -it -v ~/files:/home/nonroot/files remnux/v8 bash\n\n\n\nIn the example above, the ~/files directory will be shared between your host and the container. Before running the command above, make sure that ~/files exists and that its permissions are world-readable (i.e., \nchmod a+xwr\n).\n\n\nThe remnux/v8 image includes a file that defines several objects, methods and properties that malicious JavaScript scripts running in a standalone interpreter will require. This file is located within the container in the ~/def.js location. You might need to modify it to address the needs of your sample.\n\n\nOnce in the container, you might want to invoke the V8 application using a command like this:\n\n\nd8 -f ~/def.js ~/files/file.js\n\n\n\nThug Low-Interaction Honeyclient: remnux/thug\n\n\nThug\n low-interaction honeyclient can assist with the analysis of suspicious websites. The REMnux image of this application is available in the the Docker Hub Registry as \nremnux/thug\n.\n\n\n\n\nThe easiest way to use Thug is to invoke it by first running \nbash\n or another shell within its container, and then running the \n./thug.py\n command:\n\n\nsudo docker run --rm -it remnux/thug bash\n\n\n\nIf you will want to save the log files that Thug creates when assessing the designated website, you will want to invoke Docker with the \n-v\n parameter to specify a shared directory that the container and the underlying host will be able to access:\n\n\nsudo docker run --rm -it -v ~/logs:/home/thug/logs remnux/thug bash\n\n\n\nIn the example above, the ~/logs directory will be shared between your host and the container. Before running the command above, make sure that ~/logs exists and that its permissions are world-readable (i.e., \nchmod a+xwr\n). If you\nd like to share an additional directory (e.g., \nfiles\n), supply the mapping using another -v parameter such as \n-v ~/files:/home/thug/files\n and remember to make the directory on your host world-accessible.\n\n\nOnce in the container, you might want to invoke the Thug application using a command like this:\n\n\n./thug.py http://example.com\n\n\n\nIf you want Thug to examine a single website and don\nt need an interactive shell, you could run its image like this:\n\n\nsudo docker run --rm -it -v ~/logs:/home/thug/logs remnux/thug ./thug.py http://example.com\n\n\n\nIn the example above, we launched the Thug image and specified that the command to run within it should be \n./thug.py http://example.com\n. We also directed Docker to share the underlying host\ns ~/log directory, which is where Thug saved the results of its analysis.\n\n\n\n\nViper Binary Analysis Framework: remnux/viper\n\n\nViper\n is \na binary management and analysis framework dedicated to malware and exploit researchers.\n It\ns useful to examine samples and maintain historical records about prior investigations. The REMnux image of this application is available in the the Docker Hub Registry as \nremnux/viper\n.\n\n\n\n\nOne way to launch Viper is to simply run its container:\n\n\nsudo docker run --rm -it remnux/viper\n\n\n\nThis will automatically launch the tool. Alternatively, you could start the container by first running \nbash\n or another shell in it, and then running the \n../viper/viper.py\n command with the desired parameters:\n\n\nsudo docker run --rm -it remnux/viper bash\n\n\n\nHowever, you\nll probably want to share a directory between the container and your underlying host, so that Viper can read your samples and save its analysis. To do this, invoke Docker with the \n-v\n parameter to specify a shared directory that the container and the underlying host will be able to access:\n\n\nsudo docker run --rm -it -v ~/viper-workdir:/home/nonroot/workdir remnux/viper\n\n\n\nIn the example above, the ~/viper-workdir directory will be shared between your host and the container. Before running the command above, make sure that ~/viper-workdir exists and that its permissions are world-readable (i.e., \nchmod a+xwr\n).\n\n\nRekall Memory Forensic Framework: remnux/rekall\n\n\nRekall\n is a collection of tools for the extraction and analysis of artifacts from memory images. The REMnux image of this application is available in the the Docker Hub Registry as \nremnux/rekall\n.\n\n\n\n\nOne way to launch Rekall is to start the container by first running \nbash\n or another shell in it, and then running the \nrekall\n command with the desired parameters:\n\n\nsudo docker run --rm -it remnux/rekall bash\n\n\n\nHowever, you\nll probably want to share a directory between the container and your underlying host, so that Rekall can read your memory image files and save its output. To do this, invoke Docker with the \n-v\n parameter to specify a shared directory that the container and the underlying host will be able to access:\n\n\nsudo docker run --rm -it -v ~/files:/home/nonroot/files remnux/rekall bash\n\n\n\nIn the example above, the ~/files directory will be shared between your host and the container. Before running the command above, make sure that ~/files exists and that its permissions are world-readable (i.e., \nchmod a+xwr\n).\n\n\nTo use Rekall\ns web console, instead of its command-line interface, invoke the container with the -p parameter to give your host access to the container\ns TCP port 8000 like this:\n\n\nsudo docker run --rm -it -p 8000:8000 -v ~/files:/home/nonroot/files remnux/rekall\n\n\n\nThen connect to http://localhost:8000 using a web browser from your underlying host. To stop the container running in this mode, press \nCtrl+C\n in its terminal window.\n\n\nJSDetox JavaScript Analysis Tool: remnux/jsdetox\n\n\nJSDetox\n is a web-based tool for analyzing and deobfuscating JavaScript. The REMnux image of this application is available in the the Docker Hub Registry as \nremnux/jsdetox\n.\n\n\n\n\nOne way to launch JSDetox, run its container like this:\n\n\nsudo docker run --rm -p 3000:3000 remnux/jsdetox\n\n\n\nThen connect to http://localhost:3000 using a web browser from your underlying host.\n\n\nTo stop the JSDetox container, run \nsudo docker ps -l\n on your host to obtain the container ID, then use the \nsudo docker stop\ncontainer-id` command and wait about a minute, where \ncontainer-id\n is the ID of the JSDetox container.\n\n\nHelp expand this collection! You can put together Dockerfile configs for building Docker images of malware analysis applications that are not yet present in the repository. To do this, follow the guidelines in the article \nCreating Docker Images for REMnux\n.\n\n\nRadare2 Reverse Engineering Framework: remnux/radare2\n\n\nRadare2\n is a reverse-engineering framework that includes a disassembler and other capabilities useful for analyzing malicious code. The REMnux image of this application is available in the the Docker Hub Registry as \nremnux/radare2\n.\n\n\n\n\nTo use Radare2, first run \nbash\n or another shell in its container and then specify the \nrd2\n command with the desired parameters. You\nll probably want to share a directory between the container and your underlying host, so that Radare2 can read your samples and save its output. To do this, invoke Docker with the \n-v\n parameter to specify a shared directory that the container and the underlying host will be able to access:\n\n\nsudo docker run --rm -it -v ~/workdir:/home/nonroot/workdir remnux/radare2 bash\n\n\n\nIn the example above, the ~/workdir directory will be shared between your host and the container. Before running the command above, make sure that ~/workdir exists and that its permissions are world-readable (i.e., \nchmod a+xwr\n).\n\n\nPescanner Static Malware Analysis Tool: remnux/pescanner\n\n\nPescaner\n is a static malware analysis tool for examining suspicious Windows PE files. It was created by created by \nMichael Ligh\n and distributed with the book \nMalware Analyst Cookbook\n. The REMnux collection uses the \nversion of this tool\n that was modified by \nGlenn P. Edwards Jr.\n to introduce \nimphash\n support.\n\n\n\n\nTo use pescanner, first run \nbash\n or another shell in its container and then specify the \npescanner\n command, followed by the path to the file you\nd like to examine. You\nll probably want to share a directory between the container and your underlying host, so that pescanner can access your samples. To do this, invoke Docker with the \n-v\n parameter to specify a shared directory that the container and the underlying host will be able to access:\n\n\nsudo docker run --rm -it -v ~/workdir:/home/nonroot/workdir remnux/pescanner bash\n\n\n\nIn the example above, the ~/workdir directory will be shared between your host and the container. Before running the command above, make sure that ~/workdir exists and that its permissions are world-readable (i.e., \nchmod a+xwr\n).",
            "title": "Running REMnux-Provided Images"
        },
        {
            "loc": "/containers/run-apps/#googles-v8-javascript-engine-remnuxv8",
            "tags": "",
            "text": "Google s V8 JavaScript Engine  can be useful for obfuscating JavaScript embedded in malicious browser pages and PDF files. The REMnux image of this application is available in the the Docker Hub Registry as  remnux/v8 .   The easiest way to use V8 is to invoke it by first running  bash  or another shell within its container, and then running the  d8  command:  sudo docker run --rm -it remnux/v8 bash  However, since you ll probably want to provide some files for V8 to examine and get some files back, you will probably want to invoke Docker with the  -v  parameter to specify a shared directory that the container and the underlying host will be able to access:  sudo docker run --rm -it -v ~/files:/home/nonroot/files remnux/v8 bash  In the example above, the ~/files directory will be shared between your host and the container. Before running the command above, make sure that ~/files exists and that its permissions are world-readable (i.e.,  chmod a+xwr ).  The remnux/v8 image includes a file that defines several objects, methods and properties that malicious JavaScript scripts running in a standalone interpreter will require. This file is located within the container in the ~/def.js location. You might need to modify it to address the needs of your sample.  Once in the container, you might want to invoke the V8 application using a command like this:  d8 -f ~/def.js ~/files/file.js",
            "title": "Google&#8217;s V8 JavaScript Engine: remnux/v8"
        },
        {
            "loc": "/containers/run-apps/#thug-low-interaction-honeyclient-remnuxthug",
            "tags": "",
            "text": "Thug  low-interaction honeyclient can assist with the analysis of suspicious websites. The REMnux image of this application is available in the the Docker Hub Registry as  remnux/thug .   The easiest way to use Thug is to invoke it by first running  bash  or another shell within its container, and then running the  ./thug.py  command:  sudo docker run --rm -it remnux/thug bash  If you will want to save the log files that Thug creates when assessing the designated website, you will want to invoke Docker with the  -v  parameter to specify a shared directory that the container and the underlying host will be able to access:  sudo docker run --rm -it -v ~/logs:/home/thug/logs remnux/thug bash  In the example above, the ~/logs directory will be shared between your host and the container. Before running the command above, make sure that ~/logs exists and that its permissions are world-readable (i.e.,  chmod a+xwr ). If you d like to share an additional directory (e.g.,  files ), supply the mapping using another -v parameter such as  -v ~/files:/home/thug/files  and remember to make the directory on your host world-accessible.  Once in the container, you might want to invoke the Thug application using a command like this:  ./thug.py http://example.com  If you want Thug to examine a single website and don t need an interactive shell, you could run its image like this:  sudo docker run --rm -it -v ~/logs:/home/thug/logs remnux/thug ./thug.py http://example.com  In the example above, we launched the Thug image and specified that the command to run within it should be  ./thug.py http://example.com . We also directed Docker to share the underlying host s ~/log directory, which is where Thug saved the results of its analysis.",
            "title": "Thug Low-Interaction Honeyclient: remnux/thug"
        },
        {
            "loc": "/containers/run-apps/#viper-binary-analysis-framework-remnuxviper",
            "tags": "",
            "text": "Viper  is  a binary management and analysis framework dedicated to malware and exploit researchers.  It s useful to examine samples and maintain historical records about prior investigations. The REMnux image of this application is available in the the Docker Hub Registry as  remnux/viper .   One way to launch Viper is to simply run its container:  sudo docker run --rm -it remnux/viper  This will automatically launch the tool. Alternatively, you could start the container by first running  bash  or another shell in it, and then running the  ../viper/viper.py  command with the desired parameters:  sudo docker run --rm -it remnux/viper bash  However, you ll probably want to share a directory between the container and your underlying host, so that Viper can read your samples and save its analysis. To do this, invoke Docker with the  -v  parameter to specify a shared directory that the container and the underlying host will be able to access:  sudo docker run --rm -it -v ~/viper-workdir:/home/nonroot/workdir remnux/viper  In the example above, the ~/viper-workdir directory will be shared between your host and the container. Before running the command above, make sure that ~/viper-workdir exists and that its permissions are world-readable (i.e.,  chmod a+xwr ).",
            "title": "Viper Binary Analysis Framework: remnux/viper"
        },
        {
            "loc": "/containers/run-apps/#rekall-memory-forensic-framework-remnuxrekall",
            "tags": "",
            "text": "Rekall  is a collection of tools for the extraction and analysis of artifacts from memory images. The REMnux image of this application is available in the the Docker Hub Registry as  remnux/rekall .   One way to launch Rekall is to start the container by first running  bash  or another shell in it, and then running the  rekall  command with the desired parameters:  sudo docker run --rm -it remnux/rekall bash  However, you ll probably want to share a directory between the container and your underlying host, so that Rekall can read your memory image files and save its output. To do this, invoke Docker with the  -v  parameter to specify a shared directory that the container and the underlying host will be able to access:  sudo docker run --rm -it -v ~/files:/home/nonroot/files remnux/rekall bash  In the example above, the ~/files directory will be shared between your host and the container. Before running the command above, make sure that ~/files exists and that its permissions are world-readable (i.e.,  chmod a+xwr ).  To use Rekall s web console, instead of its command-line interface, invoke the container with the -p parameter to give your host access to the container s TCP port 8000 like this:  sudo docker run --rm -it -p 8000:8000 -v ~/files:/home/nonroot/files remnux/rekall  Then connect to http://localhost:8000 using a web browser from your underlying host. To stop the container running in this mode, press  Ctrl+C  in its terminal window.",
            "title": "Rekall Memory Forensic Framework: remnux/rekall"
        },
        {
            "loc": "/containers/run-apps/#jsdetox-javascript-analysis-tool-remnuxjsdetox",
            "tags": "",
            "text": "JSDetox  is a web-based tool for analyzing and deobfuscating JavaScript. The REMnux image of this application is available in the the Docker Hub Registry as  remnux/jsdetox .   One way to launch JSDetox, run its container like this:  sudo docker run --rm -p 3000:3000 remnux/jsdetox  Then connect to http://localhost:3000 using a web browser from your underlying host.  To stop the JSDetox container, run  sudo docker ps -l  on your host to obtain the container ID, then use the  sudo docker stop container-id` command and wait about a minute, where  container-id  is the ID of the JSDetox container.  Help expand this collection! You can put together Dockerfile configs for building Docker images of malware analysis applications that are not yet present in the repository. To do this, follow the guidelines in the article  Creating Docker Images for REMnux .",
            "title": "JSDetox JavaScript Analysis Tool: remnux/jsdetox"
        },
        {
            "loc": "/containers/run-apps/#radare2-reverse-engineering-framework-remnuxradare2",
            "tags": "",
            "text": "Radare2  is a reverse-engineering framework that includes a disassembler and other capabilities useful for analyzing malicious code. The REMnux image of this application is available in the the Docker Hub Registry as  remnux/radare2 .   To use Radare2, first run  bash  or another shell in its container and then specify the  rd2  command with the desired parameters. You ll probably want to share a directory between the container and your underlying host, so that Radare2 can read your samples and save its output. To do this, invoke Docker with the  -v  parameter to specify a shared directory that the container and the underlying host will be able to access:  sudo docker run --rm -it -v ~/workdir:/home/nonroot/workdir remnux/radare2 bash  In the example above, the ~/workdir directory will be shared between your host and the container. Before running the command above, make sure that ~/workdir exists and that its permissions are world-readable (i.e.,  chmod a+xwr ).",
            "title": "Radare2 Reverse Engineering Framework: remnux/radare2"
        },
        {
            "loc": "/containers/run-apps/#pescanner-static-malware-analysis-tool-remnuxpescanner",
            "tags": "",
            "text": "Pescaner  is a static malware analysis tool for examining suspicious Windows PE files. It was created by created by  Michael Ligh  and distributed with the book  Malware Analyst Cookbook . The REMnux collection uses the  version of this tool  that was modified by  Glenn P. Edwards Jr.  to introduce  imphash  support.   To use pescanner, first run  bash  or another shell in its container and then specify the  pescanner  command, followed by the path to the file you d like to examine. You ll probably want to share a directory between the container and your underlying host, so that pescanner can access your samples. To do this, invoke Docker with the  -v  parameter to specify a shared directory that the container and the underlying host will be able to access:  sudo docker run --rm -it -v ~/workdir:/home/nonroot/workdir remnux/pescanner bash  In the example above, the ~/workdir directory will be shared between your host and the container. Before running the command above, make sure that ~/workdir exists and that its permissions are world-readable (i.e.,  chmod a+xwr ).",
            "title": "Pescanner Static Malware Analysis Tool: remnux/pescanner"
        },
        {
            "loc": "/containers/create-docker-images/",
            "tags": "",
            "text": "Please contribute to the \nREMnux\n collection of Docker images\n of malware analysis applications. You\nll get a chance to experiment with Docker, become a master at setting up an application of your choice and expand the set of tools that other professionals can conveniently run for examining malicious software.\n\n\nAs a starting point, read the REMnux page regarding \nDocker and the notion of containers\n. Also, familiarize yourself with the approaches to \nrunning images that have already been created\n as part of the REMnux project. Next, review the guidelines and examples below. Lastly, read Docker\ns documentation for \nbuilding images using a Dockerfile\n.\n\n\nDocumenting the Build Steps in Dockerfile\n\n\nA properly-formatted Dockerfile describes the steps necessary to build and configure your application inside a Docker container in a repeatable and unattended manner. To get a sense for the structure of such files, browse the \nREMnux repository of Dockerfiles on Github\n. To explain how to build such files, we\nll use the \nJSDetox Dockerfile\n as an example.\n\n\nThe beginning of your Dockerfile should include comments that state which application is included in the image, who created the app and where it can be obtained in a traditional form. The comments should explain how the use of the image should run it. For instance:\n\n\n# This Docker image encapsulates the JSDetox malware analysis tool by @sven_t\n# from http://www.relentless-coding.com/projects/jsdetox\n#\n# To run this image after installing Docker, use the following command:\n# sudo docker run --rm -p 3000:3000 remnux/jsdetox\n# Then, connect to http://localhost:3000 using your web browser.\n\n\n\nREMnux images use a minimal Docker image of Ubuntu 14.04 as a starting point, as designated by the \nFROM\n directive below. The \nMAINTAINER\n tag explains who created and/or maintains the Dockerfile:\n\n\nFROM ubuntu:14.04\nMAINTAINER Lenny Zeltser (@lennyzeltser, www.zeltser.com)\n\n\n\nThe \nRUN\n directive below tells Docker which commands to run  inside the container when building the image. Your Dockerfile file should include the \napt-get update\n command, followed by \napt-get install -y\n and a listing of the Ubuntu packages that the application requires. Remember that the starting point for the image is a minimal Ubuntu installation, so assume that a given package is not present unless you explicitly install it:\n\n\nUSER root\nRUN apt-get update \n apt-get install -y \\\n  git \\\n  ruby \\\n  ruby-dev \\\n  bundler \\\n  build-essential \n \\\n  rm -rf /var/lib/apt/lists/*\n\n\n\nThe \nUSER\n directive above makes sure that Docker will run the \napt-get\n commands as root. Note that the \nRUN\n command above links several commands together using \n and employs \n\\\n to break this sequence of commands into multiple lines for better readability. We\nre linking several commands in this manner to slightly minimize the size of the resulting Docker image file. This is also the reason why we include the \nrm\n command to get rid of the package listing.\n\n\nThe followng \nRUN\n directive sets up the non-root user creatively named \nnonroot\n, so that commands and applications that don\nt require root provileges have a more restricted environment within which to run. Note that just as before, we\nre using \n to string together multiple commands, separating lines with \n\\\n:\n\n\nRUN groupadd -r nonroot \n \\\n  useradd -r -g nonroot -d /home/nonroot -s /sbin/nologin -c \"Nonroot User\" nonroot \n \\\n  mkdir /home/nonroot \n \\\n  chown -R nonroot:nonroot /home/nonroot\n\n\n\nThe next set of directives tells Docker to start running commands using the newly-set up \nnonroot\n user, defines the working directory to match that user\ns home directory and retrieves the code for the application we\nre installing (JSDetox, in this case):\n\n\nUSER nonroot\nWORKDIR /home/nonroot\nRUN git clone https://github.com/svent/jsdetox.git\n\n\n\nThe following instructions will install the application using the \nbundle install\n command, according the JSDetox installation instructions. Note that these instructions need to run as root to have the ability to copy the application\ns files into protected locations:\n\n\nUSER root\nWORKDIR /home/nonroot/jsdetox\nRUN bundle install\n\n\n\nThe final set of directives below tells Docker to switch back to using the \nnonroot\n user and sets the working directory to the location from which JSDetox should be launched. It also specifies which command Docker should run when this image is launched without any parameters:\n\n\nUSER nonroot\nWORKDIR /home/nonroot/jsdetox\nCMD ./jsdetox -l $HOSTNAME 2\n/dev/null\n\n\n\nBy default, JSDetox listens on \nlocalhost\n. To give us the opportunity to connect to JSDetox from outside of its container, the command above launches the tool with the \n-l\n parameter and specifies the $HOSTNAME varilable. This environment variable is automatically defined to match the hostname that Docker will assign when this container runs, which will allow JSDetox to listen on the network interface accessible from our underlying host.\n\n\nBuilding the App Image from the Dockerfile\n\n\nYour underlying system will need to be connected to the Internet when you build the Docker image, so that it can retrieve the necessary files when installing the application. Also, you\nll need to understand what is involved in setting up the app, including knowing its dependencies and configuration nuances.\n\n\nIt\ns difficult to create a Dockerfile, such as the one we reviewed above, in one shot. Inevitably, some command will run in a manner that you don\nt expect, preventing the application from installing properly. Before documenting your steps in Dockerfile, consider launching the base ubuntu:14.04 container like this:\n\n\nsudo docker run --rm -it ubuntu:14.04 bash\n\n\n\nThen, manually type and write down the commands into the container\ns shell to install the desired application. Once you\nve validated that a specific sequence of commands works, start building a Dockerfile by adding your instructions one or two at a time to validate that they work as intended.\n\n\nOnce you\nve created a Dockerfile that contains the desired directives, go to the directory where the file is present and run the following command, where \nimage-name\n is he name you\nd like to assign to the image file you\nre building:\n\n\nsudo docker build -t=image-name .\n\n\n\nBuilding the image can take some time, depending on the speed of your system and Internet connection, as Docker downloads the necessary packages and, if appropriate, compiles code.\n\n\n\n\nAfter Docker builds the image, you can run it using the following command to get a shell in the container where your application has been installed:\n\n\nsudo docker run --rm -it image-name bash\n\n\n\nOf course, \nimage-name\n in the command above should correspond to the name you\nve assigned to the image. The \n--rm\n parameter in the command above directs Docker to automatically remove the container once it finishes running. This gets rid of any changes the application may have made to the local environment when it ran, but does not remove the cached image file that represents the app on your system. The \n-it\n parameter requests that Docker open an interactive session to the container and assign a pseudo-TTY to it so you can interact with it.\n\n\nOnce you have built and tested your Dockerfile, \nshare it with Lenny Zeltser\n, so he can review it and, if appropriate, incorporate your contribution into the REMnux repository \non Github\n and \non the Docker Hub Registry\n.\n\n\nFacilitating File System and Network Interactions\n\n\nThe container will be isolated from the host system: by default it will be able to communicate over the network in the outbound direction, but won\nt accept inbound traffic. Also, if the container is invoked with the \n--rm\n parameter, its contents will  disappear after it stops running. When building the image, you might need to anticipate the user\ns need to communicate with the app inside the container over the network or to pass files in and out of the container.\n\n\nAccessing Network Ports in the Container\n\n\nIn the JSDetox example above, the application listens on TCP port 3000. In its default configuration, JSDetox listens on localhost, which would make its port inaccessible from outside its Docker container. This is why we launched JSDetox with the \n-l $HOSTNAME\n parameter\nthis directed the application to listen on the network interface that could be accessed from outside the container.\n\n\nUnless the user explicitly requests access to the container\ns port when launching its image, no ports will be accessible from the underlying system. Fortunately, Docker allows us to use the \n-p\n parameter to specify that a specific port within the container should be accessible from outside the container. For example, to access JSDetox\n port 3000, the user needs to specify \n-p 3000:3000\n. This maps the container\ns port 3000 to the underlying host\ns port 3000, allowing the user to communicate with JSDetox by connecting to http://localhost:3000 using a web browser.\n\n\nSharing Files with the Container\n\n\nThere is no need to share files with JSDetox inside the container by using the file system, because this application interacts with the user through the web browser. In contrast, some files expect the user to provide input or share output via the file system. Docker supports the \n-v\n parameter to share a directory between the underlying host and the container.\n\n\nFor example, let\ns say we wanted to share a folder with the container running the \nRekall Memory Forensic Framework\n, which is \navailable from the REMnux Docker repository\n. If the memory image file that you\nd like to analyze is located on your underlying host in the ~/files directory, you could share that directory with the Rekall container by specifying \n-v ~/files:/home/nonroot/files\n when running the application\ns image:\n\n\nsudo docker run --rm -it -v ~/files:/home/nonroot/files remnux/rekall bash\n\n\n\nThis maps the local ~/files directory to the /home/nonroot/files directory inside the container. The Rekall image is built to run the user-designated command (e.g., \nbash\n) as the user \nnonroot\n. To ensure that the non-root user has access to the underlying hosts ~/files directory, the user of the app will need to make that directory world-accessible (i.e., \nchmod a+xwr ~/files\n) before launching the container.\n\n\nThe comments in the beginning of your Dockerfile should provide guidelines for how the image should be launched to ensure that the user can provide files and communicate with ports.",
            "title": "Creating Docker Images for REMnux"
        },
        {
            "loc": "/containers/create-docker-images/#documenting-the-build-steps-in-dockerfile",
            "tags": "",
            "text": "A properly-formatted Dockerfile describes the steps necessary to build and configure your application inside a Docker container in a repeatable and unattended manner. To get a sense for the structure of such files, browse the  REMnux repository of Dockerfiles on Github . To explain how to build such files, we ll use the  JSDetox Dockerfile  as an example.  The beginning of your Dockerfile should include comments that state which application is included in the image, who created the app and where it can be obtained in a traditional form. The comments should explain how the use of the image should run it. For instance:  # This Docker image encapsulates the JSDetox malware analysis tool by @sven_t\n# from http://www.relentless-coding.com/projects/jsdetox\n#\n# To run this image after installing Docker, use the following command:\n# sudo docker run --rm -p 3000:3000 remnux/jsdetox\n# Then, connect to http://localhost:3000 using your web browser.  REMnux images use a minimal Docker image of Ubuntu 14.04 as a starting point, as designated by the  FROM  directive below. The  MAINTAINER  tag explains who created and/or maintains the Dockerfile:  FROM ubuntu:14.04\nMAINTAINER Lenny Zeltser (@lennyzeltser, www.zeltser.com)  The  RUN  directive below tells Docker which commands to run  inside the container when building the image. Your Dockerfile file should include the  apt-get update  command, followed by  apt-get install -y  and a listing of the Ubuntu packages that the application requires. Remember that the starting point for the image is a minimal Ubuntu installation, so assume that a given package is not present unless you explicitly install it:  USER root\nRUN apt-get update   apt-get install -y \\\n  git \\\n  ruby \\\n  ruby-dev \\\n  bundler \\\n  build-essential   \\\n  rm -rf /var/lib/apt/lists/*  The  USER  directive above makes sure that Docker will run the  apt-get  commands as root. Note that the  RUN  command above links several commands together using   and employs  \\  to break this sequence of commands into multiple lines for better readability. We re linking several commands in this manner to slightly minimize the size of the resulting Docker image file. This is also the reason why we include the  rm  command to get rid of the package listing.  The followng  RUN  directive sets up the non-root user creatively named  nonroot , so that commands and applications that don t require root provileges have a more restricted environment within which to run. Note that just as before, we re using   to string together multiple commands, separating lines with  \\ :  RUN groupadd -r nonroot   \\\n  useradd -r -g nonroot -d /home/nonroot -s /sbin/nologin -c \"Nonroot User\" nonroot   \\\n  mkdir /home/nonroot   \\\n  chown -R nonroot:nonroot /home/nonroot  The next set of directives tells Docker to start running commands using the newly-set up  nonroot  user, defines the working directory to match that user s home directory and retrieves the code for the application we re installing (JSDetox, in this case):  USER nonroot\nWORKDIR /home/nonroot\nRUN git clone https://github.com/svent/jsdetox.git  The following instructions will install the application using the  bundle install  command, according the JSDetox installation instructions. Note that these instructions need to run as root to have the ability to copy the application s files into protected locations:  USER root\nWORKDIR /home/nonroot/jsdetox\nRUN bundle install  The final set of directives below tells Docker to switch back to using the  nonroot  user and sets the working directory to the location from which JSDetox should be launched. It also specifies which command Docker should run when this image is launched without any parameters:  USER nonroot\nWORKDIR /home/nonroot/jsdetox\nCMD ./jsdetox -l $HOSTNAME 2 /dev/null  By default, JSDetox listens on  localhost . To give us the opportunity to connect to JSDetox from outside of its container, the command above launches the tool with the  -l  parameter and specifies the $HOSTNAME varilable. This environment variable is automatically defined to match the hostname that Docker will assign when this container runs, which will allow JSDetox to listen on the network interface accessible from our underlying host.",
            "title": "Documenting the Build Steps in Dockerfile"
        },
        {
            "loc": "/containers/create-docker-images/#building-the-app-image-from-the-dockerfile",
            "tags": "",
            "text": "Your underlying system will need to be connected to the Internet when you build the Docker image, so that it can retrieve the necessary files when installing the application. Also, you ll need to understand what is involved in setting up the app, including knowing its dependencies and configuration nuances.  It s difficult to create a Dockerfile, such as the one we reviewed above, in one shot. Inevitably, some command will run in a manner that you don t expect, preventing the application from installing properly. Before documenting your steps in Dockerfile, consider launching the base ubuntu:14.04 container like this:  sudo docker run --rm -it ubuntu:14.04 bash  Then, manually type and write down the commands into the container s shell to install the desired application. Once you ve validated that a specific sequence of commands works, start building a Dockerfile by adding your instructions one or two at a time to validate that they work as intended.  Once you ve created a Dockerfile that contains the desired directives, go to the directory where the file is present and run the following command, where  image-name  is he name you d like to assign to the image file you re building:  sudo docker build -t=image-name .  Building the image can take some time, depending on the speed of your system and Internet connection, as Docker downloads the necessary packages and, if appropriate, compiles code.   After Docker builds the image, you can run it using the following command to get a shell in the container where your application has been installed:  sudo docker run --rm -it image-name bash  Of course,  image-name  in the command above should correspond to the name you ve assigned to the image. The  --rm  parameter in the command above directs Docker to automatically remove the container once it finishes running. This gets rid of any changes the application may have made to the local environment when it ran, but does not remove the cached image file that represents the app on your system. The  -it  parameter requests that Docker open an interactive session to the container and assign a pseudo-TTY to it so you can interact with it.  Once you have built and tested your Dockerfile,  share it with Lenny Zeltser , so he can review it and, if appropriate, incorporate your contribution into the REMnux repository  on Github  and  on the Docker Hub Registry .",
            "title": "Building the App Image from the Dockerfile"
        },
        {
            "loc": "/containers/create-docker-images/#facilitating-file-system-and-network-interactions",
            "tags": "",
            "text": "The container will be isolated from the host system: by default it will be able to communicate over the network in the outbound direction, but won t accept inbound traffic. Also, if the container is invoked with the  --rm  parameter, its contents will  disappear after it stops running. When building the image, you might need to anticipate the user s need to communicate with the app inside the container over the network or to pass files in and out of the container.  Accessing Network Ports in the Container  In the JSDetox example above, the application listens on TCP port 3000. In its default configuration, JSDetox listens on localhost, which would make its port inaccessible from outside its Docker container. This is why we launched JSDetox with the  -l $HOSTNAME  parameter this directed the application to listen on the network interface that could be accessed from outside the container.  Unless the user explicitly requests access to the container s port when launching its image, no ports will be accessible from the underlying system. Fortunately, Docker allows us to use the  -p  parameter to specify that a specific port within the container should be accessible from outside the container. For example, to access JSDetox  port 3000, the user needs to specify  -p 3000:3000 . This maps the container s port 3000 to the underlying host s port 3000, allowing the user to communicate with JSDetox by connecting to http://localhost:3000 using a web browser.  Sharing Files with the Container  There is no need to share files with JSDetox inside the container by using the file system, because this application interacts with the user through the web browser. In contrast, some files expect the user to provide input or share output via the file system. Docker supports the  -v  parameter to share a directory between the underlying host and the container.  For example, let s say we wanted to share a folder with the container running the  Rekall Memory Forensic Framework , which is  available from the REMnux Docker repository . If the memory image file that you d like to analyze is located on your underlying host in the ~/files directory, you could share that directory with the Rekall container by specifying  -v ~/files:/home/nonroot/files  when running the application s image:  sudo docker run --rm -it -v ~/files:/home/nonroot/files remnux/rekall bash  This maps the local ~/files directory to the /home/nonroot/files directory inside the container. The Rekall image is built to run the user-designated command (e.g.,  bash ) as the user  nonroot . To ensure that the non-root user has access to the underlying hosts ~/files directory, the user of the app will need to make that directory world-accessible (i.e.,  chmod a+xwr ~/files ) before launching the container.  The comments in the beginning of your Dockerfile should provide guidelines for how the image should be launched to ensure that the user can provide files and communicate with ports.",
            "title": "Facilitating File System and Network Interactions"
        },
        {
            "loc": "/expand/contribute/",
            "tags": "",
            "text": "Contribute Your Expertise\n\n\nREMnux\n is maintained by \nLenny Zeltser\n with extensive help from \nDavid Westcott\n. We could use your assistance! There are several ways in which you can also contribute to the project.\n\n\nDocumentation\n\n\nWrite documentation for tools installed on the REMnux distro to expand the tips and guidelines that already exist in the \nHow to Use REMnux Tools\n section. Please format your document using the popular and easy-to-use \nMarkdown syntax\n, then \nsend your docs to Lenny Zeltser\n.\n\n\nDockerfile Configurations\n\n\nCreate Dockerfile configs for building Docker images of malware analysis applications that are not yet present in the \nREMnux Docker image collection\n. If you are new to Docker, you can learn how to \ndistribute and run apps inside containers\n and how to \nbuild your own images\n. Once you have built and tested your Dockerfile, \nshare it with Lenny Zeltser\n.\n\n\nIssues and Fixes\n\n\nIf you come across problems with tools available as part of REMnux, specially if you have suggestions for correcting the issues, please log them on the REMnux \ndistro repository\n or \nDockerfile repository\n on Github.",
            "title": "Contribute Your Expertise"
        },
        {
            "loc": "/expand/contribute/#contribute-your-expertise",
            "tags": "",
            "text": "REMnux  is maintained by  Lenny Zeltser  with extensive help from  David Westcott . We could use your assistance! There are several ways in which you can also contribute to the project.",
            "title": "Contribute Your Expertise"
        },
        {
            "loc": "/expand/contribute/#documentation",
            "tags": "",
            "text": "Write documentation for tools installed on the REMnux distro to expand the tips and guidelines that already exist in the  How to Use REMnux Tools  section. Please format your document using the popular and easy-to-use  Markdown syntax , then  send your docs to Lenny Zeltser .",
            "title": "Documentation"
        },
        {
            "loc": "/expand/contribute/#dockerfile-configurations",
            "tags": "",
            "text": "Create Dockerfile configs for building Docker images of malware analysis applications that are not yet present in the  REMnux Docker image collection . If you are new to Docker, you can learn how to  distribute and run apps inside containers  and how to  build your own images . Once you have built and tested your Dockerfile,  share it with Lenny Zeltser .",
            "title": "Dockerfile Configurations"
        },
        {
            "loc": "/expand/contribute/#issues-and-fixes",
            "tags": "",
            "text": "If you come across problems with tools available as part of REMnux, specially if you have suggestions for correcting the issues, please log them on the REMnux  distro repository  or  Dockerfile repository  on Github.",
            "title": "Issues and Fixes"
        }
    ]
};


